{"ast":null,"code":"const isObject = require('../help/is_object');\n\nconst epoch = require('../help/epoch');\n\nconst secs = require('../help/secs');\n\nconst getKey = require('../help/get_key');\n\nconst JWS = require('../jws');\n\nconst _require = require('../jwks'),\n      KeyStore = _require.KeyStore;\n\nconst _require2 = require('../errors'),\n      JWTClaimInvalid = _require2.JWTClaimInvalid;\n\nconst _require3 = require('./shared_validations'),\n      isString = _require3.isString,\n      isNotString = _require3.isNotString;\n\nconst decode = require('./decode');\n\nconst isPayloadString = isString.bind(undefined, JWTClaimInvalid);\nconst isOptionString = isString.bind(undefined, TypeError);\n\nconst isTimestamp = (value, label, required = false) => {\n  if (required && value === undefined) {\n    throw new JWTClaimInvalid(\"\\\"\".concat(label, \"\\\" claim is missing\"));\n  }\n\n  if (value !== undefined && (typeof value !== 'number' || !Number.isSafeInteger(value))) {\n    throw new JWTClaimInvalid(\"\\\"\".concat(label, \"\\\" claim must be a unix timestamp\"));\n  }\n};\n\nconst isStringOrArrayOfStrings = (value, label, required = false) => {\n  if (required && value === undefined) {\n    throw new JWTClaimInvalid(\"\\\"\".concat(label, \"\\\" claim is missing\"));\n  }\n\n  if (value !== undefined && isNotString(value) && isNotArrayOfStrings(value)) {\n    throw new JWTClaimInvalid(\"\\\"\".concat(label, \"\\\" claim must be a string or array of strings\"));\n  }\n};\n\nconst isNotArrayOfStrings = val => !Array.isArray(val) || val.length === 0 || val.some(isNotString);\n\nconst validateOptions = options => {\n  isOptionString(options.profile, 'options.profile');\n\n  if (typeof options.complete !== 'boolean') {\n    throw new TypeError('options.complete must be a boolean');\n  }\n\n  if (typeof options.ignoreExp !== 'boolean') {\n    throw new TypeError('options.ignoreExp must be a boolean');\n  }\n\n  if (typeof options.ignoreNbf !== 'boolean') {\n    throw new TypeError('options.ignoreNbf must be a boolean');\n  }\n\n  if (typeof options.ignoreIat !== 'boolean') {\n    throw new TypeError('options.ignoreIat must be a boolean');\n  }\n\n  isOptionString(options.maxTokenAge, 'options.maxTokenAge');\n  isOptionString(options.subject, 'options.subject');\n  isOptionString(options.issuer, 'options.issuer');\n  isOptionString(options.maxAuthAge, 'options.maxAuthAge');\n  isOptionString(options.jti, 'options.jti');\n  isOptionString(options.clockTolerance, 'options.clockTolerance');\n\n  if (options.audience !== undefined && isNotString(options.audience) && isNotArrayOfStrings(options.audience)) {\n    throw new TypeError('options.audience must be a string or an array of strings');\n  }\n\n  if (options.algorithms !== undefined && isNotArrayOfStrings(options.algorithms)) {\n    throw new TypeError('options.algorithms must be an array of strings');\n  }\n\n  isOptionString(options.nonce, 'options.nonce');\n\n  if (!(options.now instanceof Date) || !options.now.getTime()) {\n    throw new TypeError('options.now must be a valid Date object');\n  }\n\n  if (options.ignoreIat && options.maxTokenAge !== undefined) {\n    throw new TypeError('options.ignoreIat and options.maxTokenAge cannot used together');\n  }\n\n  if (options.crit !== undefined && isNotArrayOfStrings(options.crit)) {\n    throw new TypeError('options.crit must be an array of strings');\n  }\n\n  switch (options.profile) {\n    case 'id_token':\n      if (!options.issuer) {\n        throw new TypeError('\"issuer\" option is required to validate an ID Token');\n      }\n\n      if (!options.audience) {\n        throw new TypeError('\"audience\" option is required to validate an ID Token');\n      }\n\n      break;\n\n    case undefined:\n      break;\n\n    default:\n      throw new TypeError(\"unsupported options.profile value \\\"\".concat(options.profile, \"\\\"\"));\n  }\n};\n\nconst validatePayloadTypes = (payload, profile) => {\n  isTimestamp(payload.iat, 'iat', profile === 'id_token');\n  isTimestamp(payload.exp, 'exp', profile === 'id_token');\n  isTimestamp(payload.auth_time, 'auth_time');\n  isTimestamp(payload.nbf, 'nbf');\n  isPayloadString(payload.jti, '\"jti\" claim');\n  isPayloadString(payload.acr, '\"acr\" claim');\n  isPayloadString(payload.nonce, '\"nonce\" claim');\n  isPayloadString(payload.iss, '\"iss\" claim', profile === 'id_token');\n  isPayloadString(payload.sub, '\"sub\" claim', profile === 'id_token');\n  isStringOrArrayOfStrings(payload.aud, 'aud', profile === 'id_token');\n  isPayloadString(payload.azp, '\"azp\" claim', profile === 'id_token' && Array.isArray(payload.aud) && payload.aud.length > 1);\n  isStringOrArrayOfStrings(payload.amr, 'amr');\n};\n\nconst checkAudiencePresence = (audPayload, audOption) => {\n  if (typeof audPayload === 'string') {\n    return audOption.includes(audPayload);\n  }\n\n  audPayload = new Set(audPayload);\n  return audOption.some(Set.prototype.has.bind(audPayload));\n};\n\nmodule.exports = (token, key, options = {}) => {\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object');\n  }\n\n  const algorithms = options.algorithms,\n        audience = options.audience,\n        clockTolerance = options.clockTolerance,\n        _options$complete = options.complete,\n        complete = _options$complete === void 0 ? false : _options$complete,\n        crit = options.crit,\n        _options$ignoreExp = options.ignoreExp,\n        ignoreExp = _options$ignoreExp === void 0 ? false : _options$ignoreExp,\n        _options$ignoreIat = options.ignoreIat,\n        ignoreIat = _options$ignoreIat === void 0 ? false : _options$ignoreIat,\n        _options$ignoreNbf = options.ignoreNbf,\n        ignoreNbf = _options$ignoreNbf === void 0 ? false : _options$ignoreNbf,\n        issuer = options.issuer,\n        jti = options.jti,\n        maxAuthAge = options.maxAuthAge,\n        maxTokenAge = options.maxTokenAge,\n        nonce = options.nonce,\n        _options$now = options.now,\n        now = _options$now === void 0 ? new Date() : _options$now,\n        subject = options.subject,\n        profile = options.profile;\n  validateOptions({\n    algorithms,\n    audience,\n    clockTolerance,\n    complete,\n    crit,\n    ignoreExp,\n    ignoreIat,\n    ignoreNbf,\n    issuer,\n    jti,\n    maxAuthAge,\n    maxTokenAge,\n    nonce,\n    now,\n    profile,\n    subject\n  });\n  const unix = epoch(now);\n  const decoded = decode(token, {\n    complete: true\n  });\n  validatePayloadTypes(decoded.payload, profile);\n\n  if (issuer && decoded.payload.iss !== issuer) {\n    throw new JWTClaimInvalid('issuer mismatch');\n  }\n\n  if (nonce && decoded.payload.nonce !== nonce) {\n    throw new JWTClaimInvalid('nonce mismatch');\n  }\n\n  if (subject && decoded.payload.sub !== subject) {\n    throw new JWTClaimInvalid('subject mismatch');\n  }\n\n  if (jti && decoded.payload.jti !== jti) {\n    throw new JWTClaimInvalid('jti mismatch');\n  }\n\n  if (audience && !checkAudiencePresence(decoded.payload.aud, typeof audience === 'string' ? [audience] : audience)) {\n    throw new JWTClaimInvalid('audience mismatch');\n  }\n\n  const tolerance = clockTolerance ? secs(clockTolerance) : 0;\n\n  if (maxAuthAge) {\n    if (!('auth_time' in decoded.payload)) {\n      throw new JWTClaimInvalid('missing auth_time');\n    }\n\n    const maxAuthAgeSeconds = secs(maxAuthAge);\n\n    if (decoded.payload.auth_time + maxAuthAgeSeconds < unix - tolerance) {\n      throw new JWTClaimInvalid('too much time has elapsed since the last End-User authentication');\n    }\n  }\n\n  if (!ignoreIat && 'iat' in decoded.payload && decoded.payload.iat > unix + tolerance) {\n    throw new JWTClaimInvalid('token issued in the future');\n  }\n\n  if (!ignoreNbf && 'nbf' in decoded.payload && decoded.payload.nbf > unix + tolerance) {\n    throw new JWTClaimInvalid('token is not active yet');\n  }\n\n  if (!ignoreExp && 'exp' in decoded.payload && decoded.payload.exp <= unix - tolerance) {\n    throw new JWTClaimInvalid('token is expired');\n  }\n\n  if (maxTokenAge) {\n    if (!('iat' in decoded.payload)) {\n      throw new JWTClaimInvalid('missing iat claim');\n    }\n\n    if (decoded.payload.iat + secs(maxTokenAge) < unix + tolerance) {\n      throw new JWTClaimInvalid('maxTokenAge exceeded');\n    }\n  }\n\n  if (profile === 'id_token' && Array.isArray(decoded.payload.aud) && decoded.payload.aud.length > 1 && decoded.payload.azp !== audience) {\n    throw new JWTClaimInvalid('azp mismatch');\n  }\n\n  key = getKey(key, true);\n\n  if (complete && key instanceof KeyStore) {\n    var _JWS$verify = JWS.verify(token, key, {\n      crit,\n      algorithms,\n      complete: true\n    });\n\n    key = _JWS$verify.key;\n  } else {\n    JWS.verify(token, key, {\n      crit,\n      algorithms\n    });\n  }\n\n  return complete ? { ...decoded,\n    key\n  } : decoded.payload;\n};","map":null,"metadata":{},"sourceType":"script"}