{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nconst url = require('url');\n\nconst _require = require('util'),\n      format = _require.format;\n\nconst cloneDeep = require('lodash/cloneDeep');\n\nconst _require2 = require('./errors'),\n      RPError = _require2.RPError,\n      OPError = _require2.OPError;\n\nconst _require3 = require('./client'),\n      BaseClient = _require3.BaseClient;\n\nconst _require4 = require('./helpers/generators'),\n      random = _require4.random,\n      codeChallenge = _require4.codeChallenge;\n\nconst pick = require('./helpers/pick');\n\nconst _require5 = require('./helpers/client'),\n      resolveResponseType = _require5.resolveResponseType,\n      resolveRedirectUri = _require5.resolveRedirectUri;\n\nfunction verified(err, user, info = {}) {\n  if (err) {\n    this.error(err);\n  } else if (!user) {\n    this.fail(info);\n  } else {\n    this.success(user, info);\n  }\n}\n/**\n * @name constructor\n * @api public\n */\n\n\nfunction OpenIDConnectStrategy({\n  client,\n  params = {},\n  passReqToCallback = false,\n  sessionKey,\n  usePKCE = false\n} = {}, verify) {\n  if (!(client instanceof BaseClient)) {\n    throw new TypeError('client must be an instance of openid-client Client');\n  }\n\n  if (typeof verify !== 'function') {\n    throw new TypeError('verify callback must be a function');\n  }\n\n  if (!client.issuer || !client.issuer.issuer) {\n    throw new TypeError('client must have an issuer with an identifier');\n  }\n\n  this._client = client;\n  this._issuer = client.issuer;\n  this._verify = verify;\n  this._passReqToCallback = passReqToCallback;\n  this._usePKCE = usePKCE;\n  this._key = sessionKey || \"oidc:\".concat(url.parse(this._issuer.issuer).hostname);\n  this._params = cloneDeep(params);\n\n  if (this._usePKCE === true) {\n    const supportedMethods = this._issuer.code_challenge_methods_supported;\n\n    if (!Array.isArray(supportedMethods)) {\n      throw new TypeError('code_challenge_methods_supported is not properly set on issuer');\n    }\n\n    if (supportedMethods.includes('S256')) {\n      this._usePKCE = 'S256';\n    } else if (supportedMethods.includes('plain')) {\n      this._usePKCE = 'plain';\n    } else {\n      throw new TypeError('neither supported code_challenge_method is supported by the issuer');\n    }\n  } else if (typeof this._usePKCE === 'string' && !['plain', 'S256'].includes(this._usePKCE)) {\n    throw new TypeError(\"\".concat(this._usePKCE, \" is not valid/implemented PKCE code_challenge_method\"));\n  }\n\n  this.name = url.parse(client.issuer.issuer).hostname;\n  if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);\n  if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);\n  if (!this._params.scope) this._params.scope = 'openid';\n}\n\nOpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {\n  (async () => {\n    const client = this._client;\n\n    if (!req.session) {\n      throw new TypeError('authentication requires session support');\n    }\n\n    const reqParams = client.callbackParams(req);\n    const sessionKey = this._key;\n    /* start authentication request */\n\n    if (Object.keys(reqParams).length === 0) {\n      // provide options object with extra authentication parameters\n      const params = {\n        state: random(),\n        ...this._params,\n        ...options\n      };\n\n      if (!params.nonce && params.response_type.includes('id_token')) {\n        params.nonce = random();\n      }\n\n      req.session[sessionKey] = pick(params, 'nonce', 'state', 'max_age', 'response_type');\n\n      if (this._usePKCE) {\n        const verifier = random();\n        req.session[sessionKey].code_verifier = verifier;\n\n        switch (this._usePKCE) {\n          // eslint-disable-line default-case\n          case 'S256':\n            params.code_challenge = codeChallenge(verifier);\n            params.code_challenge_method = 'S256';\n            break;\n\n          case 'plain':\n            params.code_challenge = verifier;\n            break;\n        }\n      }\n\n      this.redirect(client.authorizationUrl(params));\n      return;\n    }\n    /* end authentication request */\n\n    /* start authentication response */\n\n\n    const session = req.session[sessionKey];\n\n    if (Object.keys(session || {}).length === 0) {\n      throw new Error(format('did not find expected authorization request details in session, req.session[\"%s\"] is %j', sessionKey, session));\n    }\n\n    const state = session.state,\n          nonce = session.nonce,\n          maxAge = session.max_age,\n          codeVerifier = session.code_verifier,\n          responseType = session.response_type;\n\n    try {\n      delete req.session[sessionKey];\n    } catch (err) {}\n\n    const opts = {\n      redirect_uri: this._params.redirect_uri,\n      ...options\n    };\n    const checks = {\n      state,\n      nonce,\n      max_age: maxAge,\n      code_verifier: codeVerifier,\n      response_type: responseType\n    };\n    const tokenset = await client.callback(opts.redirect_uri, reqParams, checks);\n    const passReq = this._passReqToCallback;\n    const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;\n    const args = [tokenset, verified.bind(this)];\n\n    if (loadUserinfo) {\n      if (!tokenset.access_token) {\n        throw new RPError({\n          message: 'expected access_token to be returned when asking for userinfo in verify callback',\n          tokenset\n        });\n      }\n\n      const userinfo = await client.userinfo(tokenset);\n      args.splice(1, 0, userinfo);\n    }\n\n    if (passReq) {\n      args.unshift(req);\n    }\n\n    this._verify(...args);\n    /* end authentication response */\n\n  })().catch(error => {\n    if (error instanceof OPError && error.error !== 'server_error' && !error.error.startsWith('invalid') || error instanceof RPError) {\n      this.fail(error);\n    } else {\n      this.error(error);\n    }\n  });\n};\n\nmodule.exports = OpenIDConnectStrategy;","map":null,"metadata":{},"sourceType":"script"}