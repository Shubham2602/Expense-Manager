{"ast":null,"code":"const isObject = require('../help/is_object');\n\nconst secs = require('../help/secs');\n\nconst epoch = require('../help/epoch');\n\nconst getKey = require('../help/get_key');\n\nconst JWS = require('../jws');\n\nconst isString = require('./shared_validations').isString.bind(undefined, TypeError);\n\nconst validateOptions = options => {\n  if (typeof options.iat !== 'boolean') {\n    throw new TypeError('options.iat must be a boolean');\n  }\n\n  if (typeof options.kid !== 'boolean') {\n    throw new TypeError('options.kid must be a boolean');\n  }\n\n  isString(options.subject, 'options.subject');\n  isString(options.issuer, 'options.issuer');\n\n  if (options.audience !== undefined && (typeof options.audience !== 'string' || !options.audience) && (!Array.isArray(options.audience) || options.audience.length === 0 || options.audience.some(a => !a || typeof a !== 'string'))) {\n    throw new TypeError('options.audience must be a string or an array of strings');\n  }\n\n  if (options.header !== undefined && !isObject(options.header)) {\n    throw new TypeError('options.header must be an object');\n  }\n\n  isString(options.algorithm, 'options.algorithm');\n  isString(options.expiresIn, 'options.expiresIn');\n  isString(options.notBefore, 'options.notBefore');\n  isString(options.jti, 'options.jti');\n  isString(options.nonce, 'options.nonce');\n\n  if (!(options.now instanceof Date) || !options.now.getTime()) {\n    throw new TypeError('options.now must be a valid Date object');\n  }\n};\n\nmodule.exports = (payload, key, options = {}) => {\n  if (!isObject(options)) {\n    throw new TypeError('options must be an object');\n  }\n\n  const algorithm = options.algorithm,\n        audience = options.audience,\n        expiresIn = options.expiresIn,\n        _options$header = options.header,\n        header = _options$header === void 0 ? {} : _options$header,\n        _options$iat = options.iat,\n        iat = _options$iat === void 0 ? true : _options$iat,\n        issuer = options.issuer,\n        jti = options.jti,\n        _options$kid = options.kid,\n        kid = _options$kid === void 0 ? true : _options$kid,\n        nonce = options.nonce,\n        notBefore = options.notBefore,\n        subject = options.subject,\n        _options$now = options.now,\n        now = _options$now === void 0 ? new Date() : _options$now;\n  validateOptions({\n    algorithm,\n    audience,\n    expiresIn,\n    header,\n    iat,\n    issuer,\n    jti,\n    kid,\n    nonce,\n    notBefore,\n    now,\n    subject\n  });\n\n  if (!isObject(payload)) {\n    throw new TypeError('payload must be an object');\n  }\n\n  const unix = epoch(now);\n  payload = { ...payload,\n    sub: subject || payload.sub,\n    aud: audience || payload.aud,\n    iss: issuer || payload.iss,\n    jti: jti || payload.jti,\n    iat: iat ? unix : payload.iat,\n    nonce: nonce || payload.nonce,\n    exp: expiresIn ? unix + secs(expiresIn) : payload.exp,\n    nbf: notBefore ? unix + secs(notBefore) : payload.nbf\n  };\n  key = getKey(key);\n  let includeKid;\n\n  if (typeof options.kid === 'boolean') {\n    includeKid = kid;\n  } else if (key.secret) {\n    includeKid = false;\n  } else {\n    includeKid = true;\n  }\n\n  return JWS.sign(payload, key, { ...header,\n    alg: algorithm || header.alg,\n    kid: includeKid ? key.kid : header.kid\n  });\n};","map":null,"metadata":{},"sourceType":"script"}