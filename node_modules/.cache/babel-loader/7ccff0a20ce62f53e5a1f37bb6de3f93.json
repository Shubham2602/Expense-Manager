{"ast":null,"code":"'use strict';\n\nconst AggregateError = require('aggregate-error');\n\nconst PCancelable = require('p-cancelable');\n\nconst pSome = (iterable, options) => new PCancelable((resolve, reject, onCancel) => {\n  options = {\n    filter: () => true,\n    ...options\n  };\n\n  if (!Number.isFinite(options.count)) {\n    throw new TypeError(\"Expected a finite number, got \".concat(typeof options.count));\n  }\n\n  const values = [];\n  const errors = [];\n  let elementCount = 0;\n  let maxErrors = -options.count + 1;\n  let maxFiltered = -options.count + 1;\n  let isDone = false;\n  const completed = new Set();\n\n  const cancelPendingIfDone = () => {\n    if (!isDone) {\n      return;\n    }\n\n    for (const promise of iterable) {\n      if (!completed.has(promise) && typeof promise.cancel === 'function') {\n        promise.cancel();\n      }\n    }\n  };\n\n  onCancel(() => {\n    isDone = true;\n    cancelPendingIfDone();\n  });\n\n  const fulfilled = value => {\n    if (isDone) {\n      return;\n    }\n\n    if (!options.filter(value)) {\n      if (--maxFiltered === 0) {\n        isDone = true;\n        reject(new RangeError('Not enough values pass the `filter` option'));\n      }\n\n      return;\n    }\n\n    values.push(value);\n\n    if (--options.count === 0) {\n      isDone = true;\n      resolve(values);\n    }\n  };\n\n  const rejected = error => {\n    if (isDone) {\n      return;\n    }\n\n    errors.push(error);\n\n    if (--maxErrors === 0) {\n      isDone = true;\n      reject(new AggregateError(errors));\n    }\n  };\n\n  for (const element of iterable) {\n    maxErrors++;\n    maxFiltered++;\n    elementCount++;\n\n    (async () => {\n      try {\n        const value = await Promise.resolve(element);\n        fulfilled(value);\n      } catch (error) {\n        rejected(error);\n      }\n\n      completed.add(element);\n      cancelPendingIfDone();\n    })();\n  }\n\n  if (options.count > elementCount) {\n    throw new RangeError(\"Expected input to contain at least \".concat(options.count, \" items, but contains \").concat(elementCount, \" items\"));\n  }\n});\n\nmodule.exports = pSome; // TODO: Remove this for the next major release\n\nmodule.exports.default = pSome;\nmodule.exports.AggregateError = AggregateError;","map":null,"metadata":{},"sourceType":"script"}