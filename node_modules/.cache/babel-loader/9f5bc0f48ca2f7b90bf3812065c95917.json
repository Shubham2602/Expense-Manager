{"ast":null,"code":"var _slicedToArray = require(\"F:\\\\ReactJS\\\\react-oubywa\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _objectWithoutProperties = require(\"F:\\\\ReactJS\\\\react-oubywa\\\\node_modules\\\\@babel\\\\runtime/helpers/objectWithoutProperties\");\n\nconst _require = require('zlib'),\n      inflateRawSync = _require.inflateRawSync;\n\nconst base64url = require('../help/base64url');\n\nconst getKey = require('../help/get_key');\n\nconst _require2 = require('../jwks'),\n      KeyStore = _require2.KeyStore;\n\nconst errors = require('../errors');\n\nconst _require3 = require('../jwa'),\n      check = _require3.check,\n      decrypt = _require3.decrypt,\n      keyManagementDecrypt = _require3.keyManagementDecrypt;\n\nconst JWK = require('../jwk');\n\nconst _require4 = require('../help/key_object'),\n      createSecretKey = _require4.createSecretKey;\n\nconst generateCEK = require('./generate_cek');\n\nconst validateHeaders = require('./validate_headers');\n\nconst _require5 = require('./serializers'),\n      resolveSerialization = _require5.detect;\n\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened']);\n\nconst combineHeader = (prot = {}, unprotected = {}, header = {}) => {\n  if (typeof prot === 'string') {\n    prot = base64url.JSON.decode(prot);\n  }\n\n  const p2s = prot.p2s || unprotected.p2s || header.p2s;\n  const apu = prot.apu || unprotected.apu || header.apu;\n  const apv = prot.apv || unprotected.apv || header.apv;\n  const iv = prot.iv || unprotected.iv || header.iv;\n  const tag = prot.tag || unprotected.tag || header.tag;\n  return { ...prot,\n    ...unprotected,\n    ...header,\n    ...(typeof p2s === 'string' ? {\n      p2s: base64url.decodeToBuffer(p2s)\n    } : undefined),\n    ...(typeof apu === 'string' ? {\n      apu: base64url.decodeToBuffer(apu)\n    } : undefined),\n    ...(typeof apv === 'string' ? {\n      apv: base64url.decodeToBuffer(apv)\n    } : undefined),\n    ...(typeof iv === 'string' ? {\n      iv: base64url.decodeToBuffer(iv)\n    } : undefined),\n    ...(typeof tag === 'string' ? {\n      tag: base64url.decodeToBuffer(tag)\n    } : undefined)\n  };\n};\n/*\n * @public\n */\n\n\nconst jweDecrypt = (skipValidateHeaders, serialization, jwe, key, {\n  crit = [],\n  complete = false,\n  algorithms\n} = {}) => {\n  key = getKey(key, true);\n\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError('\"algorithms\" option must be an array of non-empty strings');\n  } else if (algorithms) {\n    algorithms = new Set(algorithms);\n  }\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings');\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jwe);\n  } else if (serialization !== resolveSerialization(jwe)) {\n    throw new errors.JWEInvalid();\n  }\n\n  let alg, ciphertext, enc, encryptedKey, iv, opts, prot, tag, unprotected, cek, aad, header; // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n\n  if (serialization === 'general' && jwe.recipients.length === 1) {\n    serialization = 'flattened';\n\n    const _jwe = jwe,\n          recipients = _jwe.recipients,\n          root = _objectWithoutProperties(_jwe, [\"recipients\"]);\n\n    jwe = { ...root,\n      ...recipients[0]\n    };\n  }\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    if (serialization === 'compact') {\n      // compact serialization format\n      var _jwe$split = jwe.split('.');\n\n      var _jwe$split2 = _slicedToArray(_jwe$split, 5);\n\n      prot = _jwe$split2[0];\n      encryptedKey = _jwe$split2[1];\n      iv = _jwe$split2[2];\n      ciphertext = _jwe$split2[3];\n      tag = _jwe$split2[4];\n    } else {\n      // flattened serialization format\n      var _jwe2 = jwe;\n      prot = _jwe2.protected;\n      encryptedKey = _jwe2.encrypted_key;\n      iv = _jwe2.iv;\n      ciphertext = _jwe2.ciphertext;\n      tag = _jwe2.tag;\n      unprotected = _jwe2.unprotected;\n      aad = _jwe2.aad;\n      header = _jwe2.header;\n    }\n\n    if (!skipValidateHeaders) {\n      validateHeaders(prot, unprotected, [{\n        header\n      }], true, crit);\n    }\n\n    opts = combineHeader(prot, unprotected, header);\n    var _opts = opts;\n    alg = _opts.alg;\n    enc = _opts.enc;\n\n    if (algorithms && !algorithms.has(alg === 'dir' ? enc : alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('alg not whitelisted');\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key;\n      let keys;\n\n      if (opts.alg === 'dir') {\n        keys = keystore.all({\n          kid: opts.kid,\n          alg: opts.enc,\n          key_ops: ['decrypt']\n        });\n      } else {\n        keys = keystore.all({\n          kid: opts.kid,\n          alg: opts.alg,\n          key_ops: ['unwrapKey']\n        });\n      }\n\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey();\n\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0];\n          break;\n\n        default:\n          {\n            const errs = [];\n\n            for (const key of keys) {\n              try {\n                return jweDecrypt(true, serialization, jwe, key, {\n                  crit,\n                  complete,\n                  algorithms: algorithms ? [...algorithms] : undefined\n                });\n              } catch (err) {\n                errs.push(err);\n                continue;\n              }\n            }\n\n            const multi = new errors.JOSEMultiError(errs);\n\n            if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n              throw new errors.JWEDecryptionFailed();\n            }\n\n            throw multi;\n          }\n      }\n    }\n\n    check(key, ...(alg === 'dir' ? ['decrypt', enc] : ['keyManagementDecrypt', alg]));\n\n    try {\n      if (alg === 'dir') {\n        cek = JWK.asKey(key, {\n          alg: enc,\n          use: 'enc'\n        });\n      } else if (alg === 'ECDH-ES') {\n        const unwrapped = keyManagementDecrypt(alg, key, undefined, opts);\n        cek = JWK.asKey(createSecretKey(unwrapped), {\n          alg: enc,\n          use: 'enc'\n        });\n      } else {\n        const unwrapped = keyManagementDecrypt(alg, key, base64url.decodeToBuffer(encryptedKey), opts);\n        cek = JWK.asKey(createSecretKey(unwrapped), {\n          alg: enc,\n          use: 'enc'\n        });\n      }\n    } catch (err) {\n      // To mitigate the attacks described in RFC 3218, the\n      // recipient MUST NOT distinguish between format, padding, and length\n      // errors of encrypted keys.  It is strongly recommended, in the event\n      // of receiving an improperly formatted key, that the recipient\n      // substitute a randomly generated CEK and proceed to the next step, to\n      // mitigate timing attacks.\n      cek = generateCEK(enc);\n    }\n\n    let adata;\n\n    if (aad) {\n      adata = Buffer.concat([Buffer.from(prot || ''), Buffer.from('.'), Buffer.from(aad)]);\n    } else {\n      adata = Buffer.from(prot || '');\n    }\n\n    try {\n      iv = base64url.decodeToBuffer(iv);\n    } catch (err) {}\n\n    try {\n      tag = base64url.decodeToBuffer(tag);\n    } catch (err) {}\n\n    let cleartext = decrypt(enc, cek, base64url.decodeToBuffer(ciphertext), {\n      iv,\n      tag,\n      aad: adata\n    });\n\n    if (opts.zip) {\n      cleartext = inflateRawSync(cleartext);\n    }\n\n    if (complete) {\n      const result = {\n        cleartext,\n        key,\n        cek\n      };\n      if (aad) result.aad = aad;\n      if (header) result.header = header;\n      if (unprotected) result.unprotected = unprotected;\n      if (prot) result.protected = base64url.JSON.decode(prot);\n      return result;\n    }\n\n    return cleartext;\n  }\n\n  validateHeaders(jwe.protected, jwe.unprotected, jwe.recipients.map(({\n    header\n  }) => ({\n    header\n  })), true, crit); // general serialization format\n\n  const _jwe3 = jwe,\n        recipients = _jwe3.recipients,\n        root = _objectWithoutProperties(_jwe3, [\"recipients\"]);\n\n  const errs = [];\n\n  for (const recipient of recipients) {\n    try {\n      return jweDecrypt(true, 'flattened', { ...root,\n        ...recipient\n      }, key, {\n        crit,\n        complete,\n        algorithms: algorithms ? [...algorithms] : undefined\n      });\n    } catch (err) {\n      errs.push(err);\n      continue;\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs);\n\n  if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n    throw new errors.JWEDecryptionFailed();\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey();\n  }\n\n  throw multi;\n};\n\nmodule.exports = jweDecrypt.bind(undefined, false, undefined);","map":null,"metadata":{},"sourceType":"script"}