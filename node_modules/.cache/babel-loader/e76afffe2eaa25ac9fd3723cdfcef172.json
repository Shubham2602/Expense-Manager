{"ast":null,"code":"const _require = require('crypto'),\n      randomBytes = _require.randomBytes;\n\nconst _require2 = require('../../help/key_object'),\n      createSecretKey = _require2.createSecretKey;\n\nconst base64url = require('../../help/base64url');\n\nconst _require3 = require('../../help/consts'),\n      KEYOBJECT = _require3.KEYOBJECT;\n\nconst _require4 = require('../../help/consts'),\n      THUMBPRINT_MATERIAL = _require4.THUMBPRINT_MATERIAL,\n      PUBLIC_MEMBERS = _require4.PUBLIC_MEMBERS,\n      PRIVATE_MEMBERS = _require4.PRIVATE_MEMBERS,\n      KEY_MANAGEMENT_DECRYPT = _require4.KEY_MANAGEMENT_DECRYPT,\n      KEY_MANAGEMENT_ENCRYPT = _require4.KEY_MANAGEMENT_ENCRYPT;\n\nconst Key = require('./base');\n\nconst ENC_ALGS = new Set(['A128CBC-HS256', 'A128GCM', 'A192CBC-HS384', 'A192GCM', 'A256CBC-HS512', 'A256GCM']);\nconst ENC_LEN = new Set([128, 192, 256, 384, 512]);\nconst WRAP_LEN = new Set([128, 192, 256]);\nconst OCT_PUBLIC = new Set();\nObject.freeze(OCT_PUBLIC);\nconst OCT_PRIVATE = new Set(['k']);\nObject.freeze(OCT_PRIVATE);\nconst privateApi = Symbol('privateApi'); // Octet sequence Key Type\n\nclass OctKey extends Key {\n  constructor(...args) {\n    super(...args);\n    Object.defineProperties(this, {\n      kty: {\n        value: 'oct',\n        enumerable: true\n      },\n      length: {\n        value: this[KEYOBJECT] ? this[KEYOBJECT].symmetricKeySize * 8 : undefined\n      },\n      k: {\n        enumerable: false,\n\n        get() {\n          if (this[KEYOBJECT]) {\n            Object.defineProperty(this, 'k', {\n              value: base64url.encodeBuffer(this[KEYOBJECT].export()),\n              configurable: false\n            });\n          } else {\n            Object.defineProperty(this, 'k', {\n              value: undefined,\n              configurable: false\n            });\n          }\n\n          return this.k;\n        },\n\n        configurable: true\n      }\n    });\n  }\n\n  static get [PUBLIC_MEMBERS]() {\n    return OCT_PUBLIC;\n  }\n\n  static get [PRIVATE_MEMBERS]() {\n    return OCT_PRIVATE;\n  } // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special\n  // JSON.stringify handling in V8\n\n\n  [THUMBPRINT_MATERIAL]() {\n    if (!this[KEYOBJECT]) {\n      throw new TypeError('reference \"oct\" keys without \"k\" cannot have their thumbprint calculated');\n    }\n\n    return {\n      k: this.k,\n      kty: 'oct'\n    };\n  }\n\n  algorithms(operation,\n  /* the rest is private API */\n  int, opts) {\n    const _ref = int === privateApi ? opts : {},\n          _ref$use = _ref.use,\n          use = _ref$use === void 0 ? this.use : _ref$use,\n          _ref$alg = _ref.alg,\n          alg = _ref$alg === void 0 ? this.alg : _ref$alg,\n          _ref$key_ops = _ref.key_ops,\n          ops = _ref$key_ops === void 0 ? this.key_ops : _ref$key_ops;\n\n    if (!this[KEYOBJECT]) {\n      return new Set();\n    }\n\n    if (operation === KEY_MANAGEMENT_ENCRYPT || operation === KEY_MANAGEMENT_DECRYPT) {\n      return new Set([...this.algorithms('wrapKey'), ...this.algorithms('deriveKey')]);\n    }\n\n    if (operation && ops && !ops.includes(operation)) {\n      return new Set();\n    }\n\n    if (alg) {\n      return new Set(this.algorithms(operation, privateApi, {\n        alg: null,\n        use,\n        key_ops: ops\n      }).has(alg) ? [alg] : undefined);\n    }\n\n    switch (operation) {\n      case 'deriveKey':\n        if (use === 'sig' || 'electron' in process.versions) {\n          return new Set();\n        }\n\n        return new Set(['PBES2-HS256+A128KW', 'PBES2-HS384+A192KW', 'PBES2-HS512+A256KW']);\n\n      case 'encrypt':\n      case 'decrypt':\n        if (this.use === 'sig' || !ENC_LEN.has(this.length)) {\n          return new Set();\n        }\n\n        return new Set([\"A\".concat(this.length / 2, \"CBC-HS\").concat(this.length), \"A\".concat(this.length, \"GCM\")].filter(a => ENC_ALGS.has(a)));\n\n      case 'sign':\n      case 'verify':\n        if (use === 'enc') {\n          return new Set();\n        }\n\n        return new Set(['HS256', 'HS384', 'HS512']);\n\n      case 'wrapKey':\n      case 'unwrapKey':\n        if (use === 'sig' || !WRAP_LEN.has(this.length)) {\n          return new Set();\n        }\n\n        if ('electron' in process.versions) {\n          return new Set([\"A\".concat(this.length, \"GCMKW\")]);\n        }\n\n        return new Set([\"A\".concat(this.length, \"KW\"), \"A\".concat(this.length, \"GCMKW\")]);\n\n      case undefined:\n        return new Set([// just the ops needed to return all algs regardless of its use - symmetric keys\n        ...this.algorithms('encrypt'), ...this.algorithms('decrypt'), ...this.algorithms('sign'), ...this.algorithms('verify'), ...this.algorithms('wrapKey'), ...this.algorithms('unwrapKey'), ...this.algorithms('deriveKey')]);\n\n      default:\n        throw new TypeError('invalid key operation');\n    }\n  }\n\n  static async generate(...args) {\n    return this.generateSync(...args);\n  }\n\n  static generateSync(len = 256, privat = true) {\n    if (!privat) {\n      throw new TypeError('\"oct\" keys cannot be generated as public');\n    }\n\n    if (!Number.isSafeInteger(len) || !len || len % 8 !== 0) {\n      throw new TypeError('invalid bit length');\n    }\n\n    return createSecretKey(randomBytes(len / 8));\n  }\n\n}\n\nmodule.exports = OctKey;","map":null,"metadata":{},"sourceType":"script"}