{"ast":null,"code":"var _slicedToArray = require(\"F:\\\\ReactJS\\\\react-oubywa\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _objectWithoutProperties = require(\"F:\\\\ReactJS\\\\react-oubywa\\\\node_modules\\\\@babel\\\\runtime/helpers/objectWithoutProperties\");\n\nconst base64url = require('../help/base64url');\n\nconst isDisjoint = require('../help/is_disjoint');\n\nlet validateCrit = require('../help/validate_crit');\n\nconst getKey = require('../help/get_key');\n\nconst _require = require('../jwks'),\n      KeyStore = _require.KeyStore;\n\nconst errors = require('../errors');\n\nconst _require2 = require('../jwa'),\n      check = _require2.check,\n      verify = _require2.verify;\n\nconst _require3 = require('./serializers'),\n      resolveSerialization = _require3.detect;\n\nvalidateCrit = validateCrit.bind(undefined, errors.JWSInvalid);\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened']);\n/*\n * @public\n */\n\nconst jwsVerify = (skipDisjointCheck, serialization, jws, key, {\n  crit = [],\n  complete = false,\n  algorithms,\n  parse = true,\n  encoding = 'utf8'\n} = {}) => {\n  key = getKey(key, true);\n\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError('\"algorithms\" option must be an array of non-empty strings');\n  } else if (algorithms) {\n    algorithms = new Set(algorithms);\n  }\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings');\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jws);\n  } else if (serialization !== resolveSerialization(jws)) {\n    throw new errors.JWSInvalid();\n  }\n\n  let prot; // protected header\n\n  let header; // unprotected header\n\n  let payload;\n  let signature;\n  let alg; // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n\n  if (serialization === 'general' && jws.signatures.length === 1) {\n    serialization = 'flattened';\n\n    const _jws = jws,\n          signatures = _jws.signatures,\n          root = _objectWithoutProperties(_jws, [\"signatures\"]);\n\n    jws = { ...root,\n      ...signatures[0]\n    };\n  }\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    if (serialization === 'compact') {\n      // compact serialization format\n      var _jws$split = jws.split('.');\n\n      var _jws$split2 = _slicedToArray(_jws$split, 3);\n\n      prot = _jws$split2[0];\n      payload = _jws$split2[1];\n      signature = _jws$split2[2];\n    } else {\n      // flattened serialization format\n      var _jws2 = jws;\n      prot = _jws2.protected;\n      payload = _jws2.payload;\n      signature = _jws2.signature;\n      header = _jws2.header;\n    }\n\n    if (!header) {\n      skipDisjointCheck = true;\n    }\n\n    let parsedProt = {};\n\n    if (prot) {\n      try {\n        parsedProt = base64url.JSON.decode(prot);\n      } catch (err) {\n        if (err instanceof errors.JOSEError) {\n          throw err;\n        }\n\n        throw new errors.JWSInvalid('could not parse JWS protected header');\n      }\n    } else {\n      skipDisjointCheck = skipDisjointCheck || true;\n    }\n\n    if (!skipDisjointCheck && !isDisjoint(parsedProt, header)) {\n      throw new errors.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n\n    const combinedHeader = { ...parsedProt,\n      ...header\n    };\n    validateCrit(parsedProt, header, crit);\n    alg = parsedProt.alg || header && header.alg;\n\n    if (!alg) {\n      throw new errors.JWSInvalid('missing JWS signature algorithm');\n    } else if (algorithms && !algorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('alg not whitelisted');\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key;\n      const keys = keystore.all({\n        kid: combinedHeader.kid,\n        alg: combinedHeader.alg,\n        key_ops: ['verify']\n      });\n\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey();\n\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0];\n          break;\n\n        default:\n          {\n            const errs = [];\n\n            for (const key of keys) {\n              try {\n                return jwsVerify(true, serialization, jws, key, {\n                  crit,\n                  complete,\n                  encoding,\n                  parse,\n                  algorithms: algorithms ? [...algorithms] : undefined\n                });\n              } catch (err) {\n                errs.push(err);\n                continue;\n              }\n            }\n\n            const multi = new errors.JOSEMultiError(errs);\n\n            if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\n              throw new errors.JWSVerificationFailed();\n            }\n\n            throw multi;\n          }\n      }\n    }\n\n    check(key, 'verify', alg);\n\n    if (!verify(alg, key, Buffer.from([prot, payload].join('.')), base64url.decodeToBuffer(signature))) {\n      throw new errors.JWSVerificationFailed();\n    }\n\n    if (!combinedHeader.crit || !combinedHeader.crit.includes('b64') || combinedHeader.b64) {\n      if (parse) {\n        payload = base64url.JSON.decode.try(payload, encoding);\n      } else {\n        payload = base64url.decodeToBuffer(payload);\n      }\n    }\n\n    if (complete) {\n      const result = {\n        payload,\n        key\n      };\n      if (prot) result.protected = parsedProt;\n      if (header) result.header = header;\n      return result;\n    }\n\n    return payload;\n  } // general serialization format\n\n\n  const _jws3 = jws,\n        signatures = _jws3.signatures,\n        root = _objectWithoutProperties(_jws3, [\"signatures\"]);\n\n  const errs = [];\n\n  for (const recipient of signatures) {\n    try {\n      return jwsVerify(false, 'flattened', { ...root,\n        ...recipient\n      }, key, {\n        crit,\n        complete,\n        encoding,\n        parse,\n        algorithms: algorithms ? [...algorithms] : undefined\n      });\n    } catch (err) {\n      errs.push(err);\n      continue;\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs);\n\n  if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\n    throw new errors.JWSVerificationFailed();\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey();\n  }\n\n  throw multi;\n};\n\nmodule.exports = jwsVerify.bind(undefined, false, undefined);","map":null,"metadata":{},"sourceType":"script"}