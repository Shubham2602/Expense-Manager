{"ast":null,"code":"/* global BigInt */\nconst _require = require('crypto'),\n      randomBytes = _require.randomBytes;\n\nconst base64url = require('./base64url');\n\nconst errors = require('../errors');\n\nconst ZERO = BigInt(0);\nconst ONE = BigInt(1);\nconst TWO = BigInt(2);\n\nconst toJWKParameter = n => {\n  const hex = n.toString(16);\n  return base64url.encodeBuffer(Buffer.from(hex.length % 2 === 1 ? \"0\".concat(hex) : hex, 'hex'));\n};\n\nconst fromBuffer = buf => BigInt(\"0x\".concat(buf.toString('hex')));\n\nconst bitLength = n => n.toString(2).length;\n\nconst eGcdX = (a, b) => {\n  let x = ZERO;\n  let y = ONE;\n  let u = ONE;\n  let v = ZERO;\n\n  while (a !== ZERO) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    b = a;\n    a = r;\n    x = u;\n    y = v;\n    u = m;\n    v = n;\n  }\n\n  return x;\n};\n\nconst gcd = (a, b) => {\n  let shift = ZERO;\n\n  while (!((a | b) & ONE)) {\n    a >>= ONE;\n    b >>= ONE;\n    shift++;\n  }\n\n  while (!(a & ONE)) {\n    a >>= ONE;\n  }\n\n  do {\n    while (!(b & ONE)) {\n      b >>= ONE;\n    }\n\n    if (a > b) {\n      const x = a;\n      a = b;\n      b = x;\n    }\n\n    b -= a;\n  } while (b);\n\n  return a << shift;\n};\n\nconst modPow = (a, b, n) => {\n  a = toZn(a, n);\n  let result = ONE;\n  let x = a;\n\n  while (b > 0) {\n    var leastSignificantBit = b % TWO;\n    b = b / TWO;\n\n    if (leastSignificantBit === ONE) {\n      result = result * x;\n      result = result % n;\n    }\n\n    x = x * x;\n    x = x % n;\n  }\n\n  return result;\n};\n\nconst randBetween = (min, max) => {\n  const interval = max - min;\n  const bitLen = bitLength(interval);\n  let rnd;\n\n  do {\n    rnd = fromBuffer(randBits(bitLen));\n  } while (rnd > interval);\n\n  return rnd + min;\n};\n\nconst randBits = bitLength => {\n  const byteLength = Math.ceil(bitLength / 8);\n  const rndBytes = randomBytes(byteLength); // Fill with 0's the extra bits\n\n  rndBytes[0] = rndBytes[0] & 2 ** (bitLength % 8) - 1;\n  return rndBytes;\n};\n\nconst toZn = (a, n) => {\n  a = a % n;\n  return a < 0 ? a + n : a;\n};\n\nconst odd = n => {\n  let r = n;\n\n  while (r % TWO === ZERO) {\n    r = r / TWO;\n  }\n\n  return r;\n}; // not sold on these values\n\n\nconst maxCountWhileNoY = 30;\nconst maxCountWhileInot0 = 22;\n\nconst getPrimeFactors = (e, d, n) => {\n  const r = odd(e * d - ONE);\n  let countWhileNoY = 0;\n  let y;\n\n  do {\n    countWhileNoY++;\n\n    if (countWhileNoY === maxCountWhileNoY) {\n      throw new errors.JWKImportFailed('failed to calculate missing primes');\n    }\n\n    let countWhileInot0 = 0;\n    let i = modPow(randBetween(TWO, n), r, n);\n    let o = ZERO;\n\n    while (i !== ONE) {\n      countWhileInot0++;\n\n      if (countWhileInot0 === maxCountWhileInot0) {\n        throw new errors.JWKImportFailed('failed to calculate missing primes');\n      }\n\n      o = i;\n      i = i * i % n;\n    }\n\n    if (o !== n - ONE) {\n      y = o;\n    }\n  } while (!y);\n\n  const p = gcd(y - ONE, n);\n  const q = n / p;\n  return p > q ? {\n    p,\n    q\n  } : {\n    p: q,\n    q: p\n  };\n};\n\nmodule.exports = jwk => {\n  const e = fromBuffer(base64url.decodeToBuffer(jwk.e));\n  const d = fromBuffer(base64url.decodeToBuffer(jwk.d));\n  const n = fromBuffer(base64url.decodeToBuffer(jwk.n));\n\n  if (d >= n) {\n    throw new errors.JWKInvalid('invalid RSA private exponent');\n  }\n\n  const _getPrimeFactors = getPrimeFactors(e, d, n),\n        p = _getPrimeFactors.p,\n        q = _getPrimeFactors.q;\n\n  const dp = d % (p - ONE);\n  const dq = d % (q - ONE);\n  const qi = toZn(eGcdX(toZn(q, p), p), p);\n  return { ...jwk,\n    p: toJWKParameter(p),\n    q: toJWKParameter(q),\n    dp: toJWKParameter(dp),\n    dq: toJWKParameter(dq),\n    qi: toJWKParameter(qi)\n  };\n};","map":null,"metadata":{},"sourceType":"script"}