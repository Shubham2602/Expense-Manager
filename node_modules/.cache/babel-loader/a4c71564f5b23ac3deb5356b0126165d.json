{"ast":null,"code":"const _require = require('os'),\n      EOL = _require.EOL;\n\nconst _require2 = require('../jwk/key/secp256k1_crv'),\n      secp256k1 = _require2.name;\n\nconst errors = require('../errors');\n\nconst _require3 = require('./key_object'),\n      createPublicKey = _require3.createPublicKey;\n\nconst base64url = require('./base64url');\n\nconst asn1 = require('./asn1');\n\nconst computePrimes = require('./rsa_primes');\n\nconst _require4 = require('./consts'),\n      OKP_CURVES = _require4.OKP_CURVES,\n      EC_CURVES = _require4.EC_CURVES;\n\nconst BN = asn1.bignum;\nconst oidHexToCurve = new Map([['06082a8648ce3d030107', 'P-256'], ['06052b8104000a', secp256k1], ['06052b81040022', 'P-384'], ['06052b81040023', 'P-521']]);\nconst EC_KEY_OID = '1.2.840.10045.2.1'.split('.');\nconst crvToOid = new Map([['P-256', '1.2.840.10045.3.1.7'.split('.')], [secp256k1, '1.3.132.0.10'.split('.')], ['P-384', '1.3.132.0.34'.split('.')], ['P-521', '1.3.132.0.35'.split('.')]]);\nconst crvToOidBuf = new Map([['P-256', Buffer.from('06082a8648ce3d030107', 'hex')], [secp256k1, Buffer.from('06052b8104000a', 'hex')], ['P-384', Buffer.from('06052b81040022', 'hex')], ['P-521', Buffer.from('06052b81040023', 'hex')]]);\n\nconst formatPem = (base64pem, descriptor) => \"-----BEGIN \".concat(descriptor, \" KEY-----\").concat(EOL).concat(base64pem.match(/.{1,64}/g).join(EOL)).concat(EOL, \"-----END \").concat(descriptor, \" KEY-----\");\n\nconst okpToJWK = {\n  private(crv, keyObject) {\n    const der = keyObject.export({\n      type: 'pkcs8',\n      format: 'der'\n    });\n    const OneAsymmetricKey = asn1.get('OneAsymmetricKey');\n\n    const _OneAsymmetricKey$dec = OneAsymmetricKey.decode(der),\n          d = _OneAsymmetricKey$dec.privateKey.privateKey;\n\n    return { ...okpToJWK.public(crv, createPublicKey(keyObject)),\n      d: base64url.encodeBuffer(d)\n    };\n  },\n\n  public(crv, keyObject) {\n    const der = keyObject.export({\n      type: 'spki',\n      format: 'der'\n    });\n    const PublicKeyInfo = asn1.get('PublicKeyInfo');\n\n    const _PublicKeyInfo$decode = PublicKeyInfo.decode(der),\n          x = _PublicKeyInfo$decode.publicKey.data;\n\n    return {\n      kty: 'OKP',\n      crv,\n      x: base64url.encodeBuffer(x)\n    };\n  }\n\n};\nconst keyObjectToJWK = {\n  rsa: {\n    private(keyObject) {\n      const der = keyObject.export({\n        type: 'pkcs8',\n        format: 'der'\n      });\n      const PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n      const RSAPrivateKey = asn1.get('RSAPrivateKey');\n\n      const _PrivateKeyInfo$decod = PrivateKeyInfo.decode(der),\n            privateKey = _PrivateKeyInfo$decod.privateKey;\n\n      const _RSAPrivateKey$decode = RSAPrivateKey.decode(privateKey),\n            version = _RSAPrivateKey$decode.version,\n            n = _RSAPrivateKey$decode.n,\n            e = _RSAPrivateKey$decode.e,\n            d = _RSAPrivateKey$decode.d,\n            p = _RSAPrivateKey$decode.p,\n            q = _RSAPrivateKey$decode.q,\n            dp = _RSAPrivateKey$decode.dp,\n            dq = _RSAPrivateKey$decode.dq,\n            qi = _RSAPrivateKey$decode.qi;\n\n      if (version !== 'two-prime') {\n        throw new errors.JOSENotSupported('Private RSA keys with more than two primes are not supported');\n      }\n\n      return {\n        kty: 'RSA',\n        n: base64url.encodeBN(n),\n        e: base64url.encodeBN(e),\n        d: base64url.encodeBN(d),\n        p: base64url.encodeBN(p),\n        q: base64url.encodeBN(q),\n        dp: base64url.encodeBN(dp),\n        dq: base64url.encodeBN(dq),\n        qi: base64url.encodeBN(qi)\n      };\n    },\n\n    public(keyObject) {\n      const der = keyObject.export({\n        type: 'spki',\n        format: 'der'\n      });\n      const PublicKeyInfo = asn1.get('PublicKeyInfo');\n      const RSAPublicKey = asn1.get('RSAPublicKey');\n\n      const _PublicKeyInfo$decode2 = PublicKeyInfo.decode(der),\n            publicKey = _PublicKeyInfo$decode2.publicKey.data;\n\n      const _RSAPublicKey$decode = RSAPublicKey.decode(publicKey),\n            n = _RSAPublicKey$decode.n,\n            e = _RSAPublicKey$decode.e;\n\n      return {\n        kty: 'RSA',\n        n: base64url.encodeBN(n),\n        e: base64url.encodeBN(e)\n      };\n    }\n\n  },\n  ec: {\n    private(keyObject) {\n      const der = keyObject.export({\n        type: 'pkcs8',\n        format: 'der'\n      });\n      const PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n      const ECPrivateKey = asn1.get('ECPrivateKey');\n\n      const _PrivateKeyInfo$decod2 = PrivateKeyInfo.decode(der),\n            privateKey = _PrivateKeyInfo$decod2.privateKey,\n            curveOid = _PrivateKeyInfo$decod2.algorithm.parameters;\n\n      const crv = oidHexToCurve.get(curveOid.toString('hex'));\n\n      const _ECPrivateKey$decode = ECPrivateKey.decode(privateKey),\n            d = _ECPrivateKey$decode.privateKey,\n            publicKey = _ECPrivateKey$decode.publicKey.data;\n\n      const x = publicKey.slice(1, (publicKey.length - 1) / 2 + 1);\n      const y = publicKey.slice((publicKey.length - 1) / 2 + 1);\n      return {\n        kty: 'EC',\n        crv,\n        d: base64url.encodeBuffer(d),\n        x: base64url.encodeBuffer(x),\n        y: base64url.encodeBuffer(y)\n      };\n    },\n\n    public(keyObject) {\n      const der = keyObject.export({\n        type: 'spki',\n        format: 'der'\n      });\n      const PublicKeyInfo = asn1.get('PublicKeyInfo');\n\n      const _PublicKeyInfo$decode3 = PublicKeyInfo.decode(der),\n            publicKey = _PublicKeyInfo$decode3.publicKey.data,\n            curveOid = _PublicKeyInfo$decode3.algorithm.parameters;\n\n      const crv = oidHexToCurve.get(curveOid.toString('hex'));\n      const x = publicKey.slice(1, (publicKey.length - 1) / 2 + 1);\n      const y = publicKey.slice((publicKey.length - 1) / 2 + 1);\n      return {\n        kty: 'EC',\n        crv,\n        x: base64url.encodeBuffer(x),\n        y: base64url.encodeBuffer(y)\n      };\n    }\n\n  },\n  ed25519: {\n    private(keyObject) {\n      return okpToJWK.private('Ed25519', keyObject);\n    },\n\n    public(keyObject) {\n      return okpToJWK.public('Ed25519', keyObject);\n    }\n\n  },\n  ed448: {\n    private(keyObject) {\n      return okpToJWK.private('Ed448', keyObject);\n    },\n\n    public(keyObject) {\n      return okpToJWK.public('Ed448', keyObject);\n    }\n\n  },\n  x25519: {\n    private(keyObject) {\n      return okpToJWK.private('X25519', keyObject);\n    },\n\n    public(keyObject) {\n      return okpToJWK.public('X25519', keyObject);\n    }\n\n  },\n  x448: {\n    private(keyObject) {\n      return okpToJWK.private('X448', keyObject);\n    },\n\n    public(keyObject) {\n      return okpToJWK.public('X448', keyObject);\n    }\n\n  }\n};\n\nmodule.exports.keyObjectToJWK = keyObject => {\n  if (keyObject.type === 'private') {\n    return keyObjectToJWK[keyObject.asymmetricKeyType].private(keyObject);\n  }\n\n  return keyObjectToJWK[keyObject.asymmetricKeyType].public(keyObject);\n};\n\nconst concatEcPublicKey = (x, y) => ({\n  unused: 0,\n  data: Buffer.concat([Buffer.alloc(1, 4), base64url.decodeToBuffer(x), base64url.decodeToBuffer(y)])\n});\n\nconst okpCrvToOid = crv => {\n  switch (crv) {\n    case 'X25519':\n      return '1.3.101.110'.split('.');\n\n    case 'X448':\n      return '1.3.101.111'.split('.');\n\n    case 'Ed25519':\n      return '1.3.101.112'.split('.');\n\n    case 'Ed448':\n      return '1.3.101.113'.split('.');\n  }\n};\n\nconst jwkToPem = {\n  RSA: {\n    private(jwk, {\n      calculateMissingRSAPrimes\n    }) {\n      const RSAPrivateKey = asn1.get('RSAPrivateKey');\n\n      if ('oth' in jwk) {\n        throw new errors.JOSENotSupported('Private RSA keys with more than two primes are not supported');\n      }\n\n      if (jwk.p || jwk.q || jwk.dp || jwk.dq || jwk.qi) {\n        if (!(jwk.p && jwk.q && jwk.dp && jwk.dq && jwk.qi)) {\n          throw new errors.JWKInvalid('all other private key parameters must be present when any one of them is present');\n        }\n      } else if (calculateMissingRSAPrimes) {\n        jwk = computePrimes(jwk);\n      } else if (!calculateMissingRSAPrimes) {\n        throw new errors.JOSENotSupported('importing private RSA keys without all other private key parameters is not enabled, see documentation and its advisory on how and when its ok to enable it');\n      }\n\n      return RSAPrivateKey.encode({\n        version: 0,\n        n: new BN(base64url.decodeToBuffer(jwk.n)),\n        e: new BN(base64url.decodeToBuffer(jwk.e)),\n        d: new BN(base64url.decodeToBuffer(jwk.d)),\n        p: new BN(base64url.decodeToBuffer(jwk.p)),\n        q: new BN(base64url.decodeToBuffer(jwk.q)),\n        dp: new BN(base64url.decodeToBuffer(jwk.dp)),\n        dq: new BN(base64url.decodeToBuffer(jwk.dq)),\n        qi: new BN(base64url.decodeToBuffer(jwk.qi))\n      }, 'pem', {\n        label: 'RSA PRIVATE KEY'\n      });\n    },\n\n    public(jwk) {\n      const RSAPublicKey = asn1.get('RSAPublicKey');\n      return RSAPublicKey.encode({\n        version: 0,\n        n: new BN(base64url.decodeToBuffer(jwk.n)),\n        e: new BN(base64url.decodeToBuffer(jwk.e))\n      }, 'pem', {\n        label: 'RSA PUBLIC KEY'\n      });\n    }\n\n  },\n  EC: {\n    private(jwk) {\n      const ECPrivateKey = asn1.get('ECPrivateKey');\n      return ECPrivateKey.encode({\n        version: 1,\n        privateKey: base64url.decodeToBuffer(jwk.d),\n        parameters: {\n          type: 'namedCurve',\n          value: crvToOid.get(jwk.crv)\n        },\n        publicKey: concatEcPublicKey(jwk.x, jwk.y)\n      }, 'pem', {\n        label: 'EC PRIVATE KEY'\n      });\n    },\n\n    public(jwk) {\n      const PublicKeyInfo = asn1.get('PublicKeyInfo');\n      return PublicKeyInfo.encode({\n        algorithm: {\n          algorithm: EC_KEY_OID,\n          parameters: crvToOidBuf.get(jwk.crv)\n        },\n        publicKey: concatEcPublicKey(jwk.x, jwk.y)\n      }, 'pem', {\n        label: 'PUBLIC KEY'\n      });\n    }\n\n  },\n  OKP: {\n    private(jwk) {\n      const OneAsymmetricKey = asn1.get('OneAsymmetricKey');\n      const b64 = OneAsymmetricKey.encode({\n        version: 0,\n        privateKey: {\n          privateKey: base64url.decodeToBuffer(jwk.d)\n        },\n        algorithm: {\n          algorithm: okpCrvToOid(jwk.crv)\n        }\n      }, 'der'); // TODO: WHYYY? https://github.com/indutny/asn1.js/issues/110\n\n      b64.write('04', 12, 1, 'hex');\n      return formatPem(b64.toString('base64'), 'PRIVATE');\n    },\n\n    public(jwk) {\n      const PublicKeyInfo = asn1.get('PublicKeyInfo');\n      return PublicKeyInfo.encode({\n        algorithm: {\n          algorithm: okpCrvToOid(jwk.crv)\n        },\n        publicKey: {\n          unused: 0,\n          data: base64url.decodeToBuffer(jwk.x)\n        }\n      }, 'pem', {\n        label: 'PUBLIC KEY'\n      });\n    }\n\n  }\n};\n\nmodule.exports.jwkToPem = (jwk, {\n  calculateMissingRSAPrimes = false\n} = {}) => {\n  switch (jwk.kty) {\n    case 'EC':\n      if (!EC_CURVES.has(jwk.crv)) {\n        throw new errors.JOSENotSupported(\"unsupported EC key curve: \".concat(jwk.crv));\n      }\n\n      break;\n\n    case 'OKP':\n      if (!OKP_CURVES.has(jwk.crv)) {\n        throw new errors.JOSENotSupported(\"unsupported OKP key curve: \".concat(jwk.crv));\n      }\n\n      break;\n\n    case 'RSA':\n      break;\n\n    default:\n      throw new errors.JOSENotSupported(\"unsupported key type: \".concat(jwk.kty));\n  }\n\n  if (jwk.d) {\n    return jwkToPem[jwk.kty].private(jwk, {\n      calculateMissingRSAPrimes\n    });\n  }\n\n  return jwkToPem[jwk.kty].public(jwk);\n};","map":null,"metadata":{},"sourceType":"script"}