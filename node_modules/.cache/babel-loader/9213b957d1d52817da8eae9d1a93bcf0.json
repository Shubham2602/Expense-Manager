{"ast":null,"code":"const isObject = require('../help/is_object');\n\nlet validateCrit = require('../help/validate_crit');\n\nconst _require = require('../errors'),\n      JWEInvalid = _require.JWEInvalid;\n\nvalidateCrit = validateCrit.bind(undefined, JWEInvalid);\n\nconst compactSerializer = (final, [recipient]) => {\n  return \"\".concat(final.protected, \".\").concat(recipient.encrypted_key, \".\").concat(final.iv, \".\").concat(final.ciphertext, \".\").concat(final.tag);\n};\n\ncompactSerializer.validate = (protectedHeader, unprotectedHeader, aad, {\n  0: {\n    header\n  },\n  length\n}) => {\n  if (length !== 1 || aad || unprotectedHeader || header) {\n    throw new JWEInvalid('JWE Compact Serialization doesn\\'t support multiple recipients, JWE unprotected headers or AAD');\n  }\n\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined);\n};\n\nconst flattenedSerializer = (final, [recipient]) => {\n  const header = recipient.header,\n        encryptedKey = recipient.encrypted_key;\n  return { ...(final.protected ? {\n      protected: final.protected\n    } : undefined),\n    ...(final.unprotected ? {\n      unprotected: final.unprotected\n    } : undefined),\n    ...(header ? {\n      header\n    } : undefined),\n    ...(encryptedKey ? {\n      encrypted_key: encryptedKey\n    } : undefined),\n    ...(final.aad ? {\n      aad: final.aad\n    } : undefined),\n    iv: final.iv,\n    ciphertext: final.ciphertext,\n    tag: final.tag\n  };\n};\n\nflattenedSerializer.validate = (protectedHeader, unprotectedHeader, aad, {\n  0: {\n    header\n  },\n  length\n}) => {\n  if (length !== 1) {\n    throw new JWEInvalid('Flattened JWE JSON Serialization doesn\\'t support multiple recipients');\n  }\n\n  validateCrit(protectedHeader, { ...unprotectedHeader,\n    ...header\n  }, protectedHeader ? protectedHeader.crit : undefined);\n};\n\nconst generalSerializer = (final, recipients) => {\n  const result = { ...(final.protected ? {\n      protected: final.protected\n    } : undefined),\n    ...(final.unprotected ? {\n      unprotected: final.unprotected\n    } : undefined),\n    recipients: recipients.map(({\n      header,\n      encrypted_key: encryptedKey,\n      generatedHeader\n    }) => {\n      if (!header && !encryptedKey && !generatedHeader) {\n        return false;\n      }\n\n      return { ...(header || generatedHeader ? {\n          header: { ...header,\n            ...generatedHeader\n          }\n        } : undefined),\n        ...(encryptedKey ? {\n          encrypted_key: encryptedKey\n        } : undefined)\n      };\n    }).filter(Boolean),\n    ...(final.aad ? {\n      aad: final.aad\n    } : undefined),\n    iv: final.iv,\n    ciphertext: final.ciphertext,\n    tag: final.tag\n  };\n\n  if (!result.recipients.length) {\n    delete result.recipients;\n  }\n\n  return result;\n};\n\ngeneralSerializer.validate = (protectedHeader, unprotectedHeader, aad, recipients) => {\n  recipients.forEach(({\n    header\n  }) => {\n    validateCrit(protectedHeader, { ...header,\n      ...unprotectedHeader\n    }, protectedHeader ? protectedHeader.crit : undefined);\n  });\n};\n\nconst isJSON = input => {\n  return isObject(input) && typeof input.ciphertext === 'string' && typeof input.iv === 'string' && typeof input.tag === 'string' && (input.unprotected === undefined || isObject(input.unprotected)) && (input.protected === undefined || typeof input.protected === 'string') && (input.aad === undefined || typeof input.aad === 'string');\n};\n\nconst isSingleRecipient = input => {\n  return (input.encrypted_key === undefined || typeof input.encrypted_key === 'string') && (input.header === undefined || isObject(input.header));\n};\n\nconst isValidRecipient = recipient => {\n  return isObject(recipient) && typeof recipient.encrypted_key === 'string' && (recipient.header === undefined || isObject(recipient.header));\n};\n\nconst isMultiRecipient = input => {\n  if (Array.isArray(input.recipients) && input.recipients.every(isValidRecipient)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst detect = input => {\n  if (typeof input === 'string' && input.split('.').length === 5) {\n    return 'compact';\n  }\n\n  if (isJSON(input)) {\n    if (isMultiRecipient(input)) {\n      return 'general';\n    }\n\n    if (isSingleRecipient(input)) {\n      return 'flattened';\n    }\n  }\n\n  throw new JWEInvalid('JWE malformed or invalid serialization');\n};\n\nmodule.exports = {\n  compact: compactSerializer,\n  flattened: flattenedSerializer,\n  general: generalSerializer,\n  detect\n};","map":null,"metadata":{},"sourceType":"script"}