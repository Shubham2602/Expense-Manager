{"ast":null,"code":"const base64url = require('../help/base64url');\n\nconst isDisjoint = require('../help/is_disjoint');\n\nconst isObject = require('../help/is_object');\n\nconst deepClone = require('../help/deep_clone');\n\nconst _require = require('../errors'),\n      JWSInvalid = _require.JWSInvalid;\n\nconst _require2 = require('../jwa'),\n      check = _require2.check,\n      sign = _require2.sign;\n\nconst getKey = require('../help/get_key');\n\nconst serializers = require('./serializers');\n\nconst PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT');\nconst map = new WeakMap();\n\nconst i = ctx => {\n  if (!map.has(ctx)) {\n    map.set(ctx, {});\n  }\n\n  return map.get(ctx);\n};\n\nclass Sign {\n  constructor(payload) {\n    if (typeof payload === 'string') {\n      payload = base64url.encode(payload);\n    } else if (Buffer.isBuffer(payload)) {\n      payload = base64url.encodeBuffer(payload);\n    } else if (isObject(payload)) {\n      payload = base64url.JSON.encode(payload);\n    } else {\n      throw new TypeError('payload argument must be a Buffer, string or an object');\n    }\n\n    i(this).payload = payload;\n    i(this).recipients = [];\n  }\n  /*\n   * @public\n   */\n\n\n  recipient(key, protectedHeader, unprotectedHeader) {\n    key = getKey(key);\n\n    if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n      throw new TypeError('protectedHeader argument must be a plain object when provided');\n    }\n\n    if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n      throw new TypeError('unprotectedHeader argument must be a plain object when provided');\n    }\n\n    if (!isDisjoint(protectedHeader, unprotectedHeader)) {\n      throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n\n    i(this).recipients.push({\n      key,\n      protectedHeader: protectedHeader ? deepClone(protectedHeader) : undefined,\n      unprotectedHeader: unprotectedHeader ? deepClone(unprotectedHeader) : undefined\n    });\n    return this;\n  }\n  /*\n   * @private\n   */\n\n\n  [PROCESS_RECIPIENT](recipient) {\n    const key = recipient.key,\n          protectedHeader = recipient.protectedHeader,\n          unprotectedHeader = recipient.unprotectedHeader;\n    const joseHeader = {\n      protected: protectedHeader || {},\n      unprotected: unprotectedHeader || {}\n    };\n    let alg = joseHeader.protected.alg || joseHeader.unprotected.alg;\n\n    if (alg) {\n      check(key, 'sign', alg);\n    } else {\n      alg = [...key.algorithms('sign')][0];\n\n      if (recipient.protectedHeader) {\n        joseHeader.protected.alg = recipient.protectedHeader.alg = alg;\n      } else {\n        joseHeader.protected = recipient.protectedHeader = {\n          alg\n        };\n      }\n    }\n\n    if (!alg) {\n      throw new JWSInvalid('could not resolve a usable \"alg\" for a recipient');\n    }\n\n    if (joseHeader.protected.crit && joseHeader.protected.crit.includes('b64')) {\n      if (i(this).b64 !== undefined && i(this).b64 !== joseHeader.protected.b64) {\n        throw new JWSInvalid('the \"b64\" Header Parameter value MUST be the same for all recipients');\n      } else {\n        i(this).b64 = joseHeader.protected.b64;\n      }\n\n      if (!joseHeader.protected.b64) {\n        i(this).payload = base64url.decode(i(this).payload);\n      }\n    }\n\n    recipient.header = unprotectedHeader;\n    recipient.protected = Object.keys(joseHeader.protected).length ? base64url.JSON.encode(joseHeader.protected) : '';\n    recipient.signature = base64url.encodeBuffer(sign(alg, key, Buffer.from(\"\".concat(recipient.protected, \".\").concat(i(this).payload))));\n  }\n  /*\n   * @public\n   */\n\n\n  sign(serialization) {\n    const serializer = serializers[serialization];\n\n    if (!serializer) {\n      throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"');\n    }\n\n    if (!i(this).recipients.length) {\n      throw new JWSInvalid('missing recipients');\n    }\n\n    serializer.validate(this, i(this).recipients);\n    i(this).recipients.forEach(this[PROCESS_RECIPIENT].bind(this));\n    return serializer(i(this).payload, i(this).recipients);\n  }\n\n}\n\nmodule.exports = Sign;","map":null,"metadata":{},"sourceType":"script"}