{"ast":null,"code":"const _require = require('assert'),\n      assert = _require.strict;\n\nconst _require2 = require('crypto'),\n      createCipheriv = _require2.createCipheriv,\n      createDecipheriv = _require2.createDecipheriv;\n\nconst uint64be = require('../help/uint64be');\n\nconst timingSafeEqual = require('../help/timing_safe_equal');\n\nconst _require3 = require('../help/consts'),\n      KEYOBJECT = _require3.KEYOBJECT;\n\nconst _require4 = require('../help/key_object'),\n      asInput = _require4.asInput;\n\nconst checkInput = data => {\n  if (data !== undefined && data.length % 8 !== 0) {\n    throw new Error('invalid data length');\n  }\n};\n\nconst IV = Buffer.alloc(8, 'a6', 'hex');\n\nconst xor = (a, b) => {\n  const len = Math.max(a.length, b.length);\n  const result = Buffer.alloc(len);\n\n  for (let idx = 0; len > idx; idx++) {\n    result[idx] = (a[idx] || 0) ^ (b[idx] || 0);\n  }\n\n  return result;\n};\n\nconst split = (input, size) => {\n  const output = [];\n\n  for (let idx = 0; input.length > idx; idx += size) {\n    output.push(input.slice(idx, idx + size));\n  }\n\n  return output;\n};\n\nconst wrapKey = (size, {\n  [KEYOBJECT]: keyObject\n}, payload) => {\n  const key = asInput(keyObject, false);\n  const iv = Buffer.alloc(16);\n  let R = split(payload, 8);\n  let A;\n  let B;\n  let count;\n  A = IV;\n\n  for (let jdx = 0; jdx < 6; jdx++) {\n    for (let idx = 0; R.length > idx; idx++) {\n      count = R.length * jdx + idx + 1;\n      const cipher = createCipheriv(\"aes\".concat(size), key, iv);\n      B = Buffer.concat([A, R[idx]]);\n      B = cipher.update(B);\n      A = xor(B.slice(0, 8), uint64be(count));\n      R[idx] = B.slice(8, 16);\n    }\n  }\n\n  R = [A].concat(R);\n  return {\n    wrapped: Buffer.concat(R)\n  };\n};\n\nconst unwrapKey = (size, {\n  [KEYOBJECT]: keyObject\n}, payload) => {\n  const key = asInput(keyObject, false);\n  checkInput(payload);\n  const iv = Buffer.alloc(16);\n  let R = split(payload, 8);\n  let A;\n  let B;\n  let count;\n  A = R[0];\n  R = R.slice(1);\n\n  for (let jdx = 5; jdx >= 0; --jdx) {\n    for (let idx = R.length - 1; idx >= 0; --idx) {\n      count = R.length * jdx + idx + 1;\n      B = xor(A, uint64be(count));\n      B = Buffer.concat([B, R[idx], iv]);\n      const cipher = createDecipheriv(\"aes\".concat(size), key, iv);\n      B = cipher.update(B);\n      A = B.slice(0, 8);\n      R[idx] = B.slice(8, 16);\n    }\n  }\n\n  if (!timingSafeEqual(IV, A)) {\n    throw new Error('unwrap failed');\n  }\n\n  return Buffer.concat(R);\n};\n\nmodule.exports = JWA => {\n  ['A128KW', 'A192KW', 'A256KW'].forEach(jwaAlg => {\n    const size = parseInt(jwaAlg.substr(1, 3), 10);\n    assert(!JWA.keyManagementEncrypt.has(jwaAlg), \"keyManagementEncrypt alg \".concat(jwaAlg, \" already registered\"));\n    assert(!JWA.keyManagementDecrypt.has(jwaAlg), \"keyManagementDecrypt alg \".concat(jwaAlg, \" already registered\"));\n    JWA.keyManagementEncrypt.set(jwaAlg, wrapKey.bind(undefined, size));\n    JWA.keyManagementDecrypt.set(jwaAlg, unwrapKey.bind(undefined, size));\n  });\n};","map":null,"metadata":{},"sourceType":"script"}