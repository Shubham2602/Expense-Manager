{"ast":null,"code":"const _require = require('crypto'),\n      createECDH = _require.createECDH,\n      createHash = _require.createHash,\n      POINT_CONVERSION_UNCOMPRESSED = _require.constants.POINT_CONVERSION_UNCOMPRESSED;\n\nconst base64url = require('../../help/base64url');\n\nconst _require2 = require('../../jwk/key/secp256k1_crv'),\n      secp256k1 = _require2.name;\n\nconst crvToCurve = crv => {\n  switch (crv) {\n    case 'P-256':\n      return 'prime256v1';\n\n    case 'P-384':\n      return 'secp384r1';\n\n    case 'P-521':\n      return 'secp521r1';\n\n    case 'secp256k1':\n    case 'X448':\n    case 'X25519':\n      return crv;\n\n    case secp256k1:\n      return 'secp256k1';\n  }\n};\n\nconst UNCOMPRESSED = Buffer.alloc(1, POINT_CONVERSION_UNCOMPRESSED);\n\nconst pubToBuffer = (x, y) => Buffer.concat([UNCOMPRESSED, base64url.decodeToBuffer(x), base64url.decodeToBuffer(y)]);\n\nconst computeSecret = ({\n  crv,\n  d\n}, {\n  x,\n  y = ''\n}) => {\n  const curve = crvToCurve(crv);\n  const exchange = createECDH(curve);\n  exchange.setPrivateKey(base64url.decodeToBuffer(d));\n  return exchange.computeSecret(pubToBuffer(x, y));\n};\n\nconst concat = (key, length, value) => {\n  const iterations = Math.ceil(length / 256);\n  let res;\n\n  for (let iter = 1; iter <= iterations; iter++) {\n    const buf = Buffer.allocUnsafe(4 + key.length + value.length);\n    buf.writeUInt32BE(iter, 0);\n    key.copy(buf, 4);\n    value.copy(buf, 4 + key.length);\n\n    if (!res) {\n      res = createHash('sha256').update(buf).digest();\n    } else {\n      res = Buffer.concat([res, createHash('sha256').update(buf).digest()]);\n    }\n  }\n\n  return res.slice(0, length);\n};\n\nconst uint32be = (value, buf = Buffer.allocUnsafe(4)) => {\n  buf.writeUInt32BE(value);\n  return buf;\n};\n\nconst lengthAndInput = input => Buffer.concat([uint32be(input.length), input]);\n\nconst concatDerive = (key, pubKey, length, value) => {\n  const shared = computeSecret(key, pubKey);\n  return concat(shared, length, value);\n};\n\nconst derive = (alg, keyLen, privKey, pubKey, {\n  apu = Buffer.alloc(0),\n  apv = Buffer.alloc(0)\n} = {}) => {\n  const value = Buffer.concat([lengthAndInput(Buffer.from(alg)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLen)]);\n  return concatDerive(privKey, pubKey, keyLen / 8, value);\n};\n\nmodule.exports = derive;","map":null,"metadata":{},"sourceType":"script"}