{"ast":null,"code":"const _require = require('util'),\n      deprecate = _require.deprecate,\n      inspect = _require.inspect;\n\nconst isObject = require('../help/is_object');\n\nconst _require2 = require('../jwk/generate'),\n      generate = _require2.generate,\n      generateSync = _require2.generateSync;\n\nconst Key = require('../jwk/key/base');\n\nconst importKey = require('../jwk/import');\n\nconst _require3 = require('../help/consts'),\n      USES_MAPPING = _require3.USES_MAPPING;\n\nconst keyscore = (key, {\n  alg,\n  use,\n  ops\n}) => {\n  let score = 0;\n\n  if (alg && key.alg) {\n    score++;\n  }\n\n  if (use && key.use) {\n    score++;\n  }\n\n  if (ops && key.key_ops) {\n    score++;\n  }\n\n  return score;\n};\n\nconst map = new WeakMap();\n\nconst i = ctx => {\n  if (!map.has(ctx)) {\n    map.set(ctx, {});\n  }\n\n  return map.get(ctx);\n};\n\nclass KeyStore {\n  constructor(...keys) {\n    while (keys.some(Array.isArray)) {\n      keys = keys.flat ? keys.flat() : keys.reduce((acc, val) => {\n        if (Array.isArray(val)) {\n          return [...acc, ...val];\n        }\n\n        acc.push(val);\n        return acc;\n      }, []);\n    }\n\n    if (keys.some(k => !(k instanceof Key))) {\n      throw new TypeError('all keys must be an instances of a key instantiated by JWK.asKey');\n    }\n\n    i(this).keys = new Set(keys);\n  }\n\n  all({\n    alg,\n    kid,\n    use,\n    kty,\n    key_ops: ops,\n    x5t,\n    'x5t#S256': x5t256,\n    crv\n  } = {}) {\n    if (ops !== undefined && (!Array.isArray(ops) || !ops.length || ops.some(x => typeof x !== 'string'))) {\n      throw new TypeError('`key_ops` must be a non-empty array of strings');\n    }\n\n    const search = {\n      alg,\n      use,\n      ops\n    };\n    return [...i(this).keys].filter(key => {\n      let candidate = true;\n\n      if (candidate && kid !== undefined && key.kid !== kid) {\n        candidate = false;\n      }\n\n      if (candidate && x5t !== undefined && key.x5t !== x5t) {\n        candidate = false;\n      }\n\n      if (candidate && x5t256 !== undefined && key['x5t#S256'] !== x5t256) {\n        candidate = false;\n      }\n\n      if (candidate && kty !== undefined && key.kty !== kty) {\n        candidate = false;\n      }\n\n      if (candidate && crv !== undefined && key.crv !== crv) {\n        candidate = false;\n      }\n\n      if (alg !== undefined && !key.algorithms().has(alg)) {\n        candidate = false;\n      }\n\n      if (candidate && use !== undefined && key.use !== undefined && key.use !== use) {\n        candidate = false;\n      } // TODO:\n\n\n      if (candidate && ops !== undefined && (key.key_ops !== undefined || key.use !== undefined)) {\n        let keyOps;\n\n        if (key.key_ops) {\n          keyOps = new Set(key.key_ops);\n        } else {\n          keyOps = USES_MAPPING[key.use];\n        }\n\n        if (ops.some(x => !keyOps.has(x))) {\n          candidate = false;\n        }\n      }\n\n      return candidate;\n    }).sort((first, second) => keyscore(second, search) - keyscore(first, search));\n  }\n\n  get(...args) {\n    return this.all(...args)[0];\n  }\n\n  add(key) {\n    if (!(key instanceof Key)) {\n      throw new TypeError('key must be an instance of a key instantiated by JWK.asKey');\n    }\n\n    i(this).keys.add(key);\n  }\n\n  remove(key) {\n    if (!(key instanceof Key)) {\n      throw new TypeError('key must be an instance of a key instantiated by JWK.asKey');\n    }\n\n    i(this).keys.delete(key);\n  }\n\n  toJWKS(priv = false) {\n    return {\n      keys: [...i(this).keys.values()].map(key => key.toJWK(priv && (key.private || key.secret && key.k)))\n    };\n  }\n\n  async generate(...args) {\n    i(this).keys.add((await generate(...args)));\n  }\n\n  generateSync(...args) {\n    i(this).keys.add(generateSync(...args));\n  }\n\n  get size() {\n    return i(this).keys.size;\n  }\n  /* c8 ignore next 8 */\n\n\n  [inspect.custom]() {\n    return \"\".concat(this.constructor.name, \" \").concat(inspect(this.toJWKS(false), {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true\n    }));\n  }\n\n  *[Symbol.iterator]() {\n    for (const key of i(this).keys) {\n      yield key;\n    }\n  }\n\n}\n\nfunction asKeyStore(jwks, {\n  ignoreErrors = false,\n  calculateMissingRSAPrimes = false\n} = {}) {\n  if (!isObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some(k => !isObject(k) || !('kty' in k))) {\n    throw new TypeError('jwks must be a JSON Web Key Set formatted object');\n  }\n\n  const keys = jwks.keys.map(jwk => {\n    try {\n      return importKey(jwk, {\n        calculateMissingRSAPrimes\n      });\n    } catch (err) {\n      if (!ignoreErrors) {\n        throw err;\n      }\n    }\n  }).filter(Boolean);\n  return new KeyStore(...keys);\n}\n\nObject.defineProperty(KeyStore, 'fromJWKS', {\n  value: deprecate(jwks => asKeyStore(jwks, {\n    calculateMissingRSAPrimes: true\n  }), 'JWKS.KeyStore.fromJWKS() is deprecated, use JWKS.asKeyStore() instead'),\n  enumerable: false\n});\nmodule.exports = {\n  KeyStore,\n  asKeyStore\n};","map":null,"metadata":{},"sourceType":"script"}