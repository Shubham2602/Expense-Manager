{"ast":null,"code":"var _slicedToArray = require(\"F:\\\\ReactJS\\\\react-oubywa\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nconst _require = require('zlib'),\n      deflateRawSync = _require.deflateRawSync;\n\nconst _require2 = require('../help/consts'),\n      KEYOBJECT = _require2.KEYOBJECT;\n\nconst generateIV = require('../help/generate_iv');\n\nconst base64url = require('../help/base64url');\n\nconst getKey = require('../help/get_key');\n\nconst isObject = require('../help/is_object');\n\nconst _require3 = require('../help/key_object'),\n      createSecretKey = _require3.createSecretKey;\n\nconst deepClone = require('../help/deep_clone');\n\nconst importKey = require('../jwk/import');\n\nconst _require4 = require('../errors'),\n      JWEInvalid = _require4.JWEInvalid;\n\nconst _require5 = require('../jwa'),\n      check = _require5.check,\n      keyManagementEncrypt = _require5.keyManagementEncrypt,\n      encrypt = _require5.encrypt;\n\nconst serializers = require('./serializers');\n\nconst generateCEK = require('./generate_cek');\n\nconst validateHeaders = require('./validate_headers');\n\nconst PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT');\nconst map = new WeakMap();\n\nconst i = ctx => {\n  if (!map.has(ctx)) {\n    map.set(ctx, {});\n  }\n\n  return map.get(ctx);\n};\n\nclass Encrypt {\n  constructor(cleartext, protectedHeader, unprotectedHeader, aad) {\n    if (!Buffer.isBuffer(cleartext) && typeof cleartext !== 'string') {\n      throw new TypeError('cleartext argument must be a Buffer or a string');\n    }\n\n    cleartext = Buffer.from(cleartext);\n\n    if (aad !== undefined && !Buffer.isBuffer(aad) && typeof aad !== 'string') {\n      throw new TypeError('aad argument must be a Buffer or a string when provided');\n    }\n\n    aad = aad ? Buffer.from(aad) : undefined;\n\n    if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n      throw new TypeError('protectedHeader argument must be a plain object when provided');\n    }\n\n    if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n      throw new TypeError('unprotectedHeader argument must be a plain object when provided');\n    }\n\n    i(this).recipients = [];\n    i(this).cleartext = cleartext;\n    i(this).aad = aad;\n    i(this).unprotected = unprotectedHeader ? deepClone(unprotectedHeader) : undefined;\n    i(this).protected = protectedHeader ? deepClone(protectedHeader) : undefined;\n  }\n  /*\n   * @public\n   */\n\n\n  recipient(key, header) {\n    key = getKey(key);\n\n    if (header !== undefined && !isObject(header)) {\n      throw new TypeError('header argument must be a plain object when provided');\n    }\n\n    i(this).recipients.push({\n      key,\n      header: header ? deepClone(header) : undefined\n    });\n    return this;\n  }\n  /*\n   * @private\n   */\n\n\n  [PROCESS_RECIPIENT](recipient) {\n    const unprotectedHeader = i(this).unprotected;\n    const protectedHeader = i(this).protected;\n    const recipientCount = i(this).recipients.length;\n    const jweHeader = { ...protectedHeader,\n      ...unprotectedHeader,\n      ...recipient.header\n    };\n    const key = recipient.key;\n    const enc = jweHeader.enc;\n    let alg = jweHeader.alg;\n\n    if (alg === 'dir') {\n      check(key, 'encrypt', enc);\n    } else if (alg) {\n      check(key, 'keyManagementEncrypt', alg);\n    } else {\n      alg = [...key.algorithms('wrapKey')][0];\n      alg = alg || [...key.algorithms('deriveKey')][0];\n\n      if (alg === 'ECDH-ES' && recipientCount !== 1) {\n        alg = [...key.algorithms('deriveKey')][1];\n      }\n\n      if (!alg) {\n        throw new JWEInvalid('could not resolve a usable \"alg\" for a recipient');\n      }\n\n      if (recipientCount === 1) {\n        if (protectedHeader) {\n          protectedHeader.alg = alg;\n        } else {\n          i(this).protected = {\n            alg\n          };\n        }\n      } else {\n        if (recipient.header) {\n          recipient.header.alg = alg;\n        } else {\n          recipient.header = {\n            alg\n          };\n        }\n      }\n    }\n\n    let wrapped;\n    let generatedHeader;\n\n    if (key.kty === 'oct' && alg === 'dir') {\n      i(this).cek = importKey(key[KEYOBJECT], {\n        use: 'enc',\n        alg: enc\n      });\n    } else {\n      var _keyManagementEncrypt = keyManagementEncrypt(alg, key, i(this).cek[KEYOBJECT].export(), {\n        enc,\n        alg\n      });\n\n      wrapped = _keyManagementEncrypt.wrapped;\n      generatedHeader = _keyManagementEncrypt.header;\n\n      if (alg === 'ECDH-ES') {\n        i(this).cek = importKey(createSecretKey(wrapped), {\n          use: 'enc',\n          alg: enc\n        });\n      }\n    }\n\n    if (alg === 'dir' || alg === 'ECDH-ES') {\n      recipient.encrypted_key = '';\n    } else {\n      recipient.encrypted_key = base64url.encodeBuffer(wrapped);\n    }\n\n    if (generatedHeader) {\n      recipient.generatedHeader = generatedHeader;\n    }\n  }\n  /*\n   * @public\n   */\n\n\n  encrypt(serialization) {\n    const serializer = serializers[serialization];\n\n    if (!serializer) {\n      throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"');\n    }\n\n    if (!i(this).recipients.length) {\n      throw new JWEInvalid('missing recipients');\n    }\n\n    serializer.validate(i(this).protected, i(this).unprotected, i(this).aad, i(this).recipients);\n    let enc = validateHeaders(i(this).protected, i(this).unprotected, i(this).recipients, false, i(this).protected ? i(this).protected.crit : undefined);\n\n    if (!enc) {\n      enc = 'A128CBC-HS256';\n\n      if (i(this).protected) {\n        i(this).protected.enc = enc;\n      } else {\n        i(this).protected = {\n          enc\n        };\n      }\n    }\n\n    const final = {};\n    i(this).cek = generateCEK(enc);\n    i(this).recipients.forEach(this[PROCESS_RECIPIENT].bind(this));\n    const iv = generateIV(enc);\n    final.iv = base64url.encodeBuffer(iv);\n\n    if (i(this).recipients.length === 1 && i(this).recipients[0].generatedHeader) {\n      const _i$recipients = _slicedToArray(i(this).recipients, 1),\n            generatedHeader = _i$recipients[0].generatedHeader;\n\n      delete i(this).recipients[0].generatedHeader;\n      i(this).protected = { ...i(this).protected,\n        ...generatedHeader\n      };\n    }\n\n    if (i(this).protected) {\n      final.protected = base64url.JSON.encode(i(this).protected);\n    }\n\n    final.unprotected = i(this).unprotected;\n    let aad;\n\n    if (i(this).aad) {\n      final.aad = base64url.encode(i(this).aad);\n      aad = Buffer.concat([Buffer.from(final.protected || ''), Buffer.from('.'), Buffer.from(final.aad)]);\n    } else {\n      aad = Buffer.from(final.protected || '');\n    }\n\n    let cleartext = i(this).cleartext;\n\n    if (i(this).protected && 'zip' in i(this).protected) {\n      cleartext = deflateRawSync(cleartext);\n    }\n\n    const _encrypt = encrypt(enc, i(this).cek, cleartext, {\n      iv,\n      aad\n    }),\n          ciphertext = _encrypt.ciphertext,\n          tag = _encrypt.tag;\n\n    final.tag = base64url.encodeBuffer(tag);\n    final.ciphertext = base64url.encodeBuffer(ciphertext);\n    return serializer(final, i(this).recipients);\n  }\n\n}\n\nmodule.exports = Encrypt;","map":null,"metadata":{},"sourceType":"script"}