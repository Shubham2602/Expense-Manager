{"ast":null,"code":"const _require = require('crypto'),\n      generateKeyPairSync = _require.generateKeyPairSync,\n      async = _require.generateKeyPair;\n\nconst _require2 = require('util'),\n      promisify = _require2.promisify;\n\nconst _require3 = require('../../help/consts'),\n      THUMBPRINT_MATERIAL = _require3.THUMBPRINT_MATERIAL,\n      JWK_MEMBERS = _require3.JWK_MEMBERS,\n      PUBLIC_MEMBERS = _require3.PUBLIC_MEMBERS,\n      EC_CURVES = _require3.EC_CURVES,\n      PRIVATE_MEMBERS = _require3.PRIVATE_MEMBERS,\n      KEY_MANAGEMENT_DECRYPT = _require3.KEY_MANAGEMENT_DECRYPT,\n      KEY_MANAGEMENT_ENCRYPT = _require3.KEY_MANAGEMENT_ENCRYPT,\n      ECDH_ALGS = _require3.ECDH_ALGS;\n\nconst _require4 = require('../../help/runtime_support'),\n      keyObjectSupported = _require4.keyObjectSupported;\n\nconst _require5 = require('../../help/key_object'),\n      createPublicKey = _require5.createPublicKey,\n      createPrivateKey = _require5.createPrivateKey;\n\nconst errors = require('../../errors');\n\nconst _require6 = require('./secp256k1_crv'),\n      secp256k1 = _require6.name;\n\nconst Key = require('./base');\n\nconst generateKeyPair = promisify(async);\nconst EC_PUBLIC = new Set(['crv', 'x', 'y']);\nObject.freeze(EC_PUBLIC);\nconst EC_PRIVATE = new Set([...EC_PUBLIC, 'd']);\nObject.freeze(EC_PRIVATE);\n\nconst crvToDSA = crv => {\n  switch (crv) {\n    case 'P-256':\n      return 'ES256';\n\n    case secp256k1:\n      return 'ES256K';\n\n    case 'P-384':\n      return 'ES384';\n\n    case 'P-521':\n      return 'ES512';\n  }\n};\n\nconst privateApi = Symbol('privateApi'); // Elliptic Curve Key Type\n\nclass ECKey extends Key {\n  constructor(...args) {\n    super(...args);\n    this[JWK_MEMBERS]();\n    Object.defineProperty(this, 'kty', {\n      value: 'EC',\n      enumerable: true\n    });\n\n    if (!this.crv) {\n      throw new errors.JOSENotSupported('unsupported EC key curve');\n    }\n  }\n\n  static get [PUBLIC_MEMBERS]() {\n    return EC_PUBLIC;\n  }\n\n  static get [PRIVATE_MEMBERS]() {\n    return EC_PRIVATE;\n  } // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special\n  // JSON.stringify handling in V8\n\n\n  [THUMBPRINT_MATERIAL]() {\n    return {\n      crv: this.crv,\n      kty: 'EC',\n      x: this.x,\n      y: this.y\n    };\n  }\n\n  algorithms(operation,\n  /* the rest is private API */\n  int, opts) {\n    const _ref = int === privateApi ? opts : {},\n          _ref$use = _ref.use,\n          use = _ref$use === void 0 ? this.use : _ref$use,\n          _ref$alg = _ref.alg,\n          alg = _ref$alg === void 0 ? this.alg : _ref$alg,\n          _ref$key_ops = _ref.key_ops,\n          ops = _ref$key_ops === void 0 ? this.key_ops : _ref$key_ops;\n\n    if (alg) {\n      return new Set(this.algorithms(operation, privateApi, {\n        alg: null,\n        use,\n        key_ops: ops\n      }).has(alg) ? [alg] : undefined);\n    }\n\n    if (operation === KEY_MANAGEMENT_ENCRYPT) {\n      operation = 'deriveKey';\n    } else if (operation === KEY_MANAGEMENT_DECRYPT) {\n      if (this.public) {\n        return new Set();\n      }\n\n      operation = 'deriveKey';\n    }\n\n    if (operation && ops && !ops.includes(operation)) {\n      return new Set();\n    }\n\n    switch (operation) {\n      case 'wrapKey':\n      case 'unwrapKey':\n      case 'encrypt':\n      case 'decrypt':\n        return new Set();\n\n      case 'sign':\n        if (this.public || use === 'enc') {\n          return new Set();\n        }\n\n        return new Set([crvToDSA(this.crv)]);\n\n      case 'verify':\n        if (use === 'enc') {\n          return new Set();\n        }\n\n        return new Set([crvToDSA(this.crv)]);\n\n      case 'deriveKey':\n        if (use === 'sig' || this.crv === secp256k1) {\n          return new Set();\n        }\n\n        return new Set(ECDH_ALGS);\n\n      case undefined:\n        // just the ops needed to return all algs regardless of its use\n        return new Set([...this.algorithms('sign'), ...this.algorithms('verify'), ...this.algorithms('deriveKey')]);\n\n      default:\n        throw new TypeError('invalid key operation');\n    }\n  }\n\n  static async generate(crv = 'P-256', privat = true) {\n    if (!EC_CURVES.has(crv)) {\n      throw new errors.JOSENotSupported(\"unsupported EC key curve: \".concat(crv));\n    }\n\n    if (crv === secp256k1 && crv !== 'secp256k1') {\n      crv = 'secp256k1';\n    }\n\n    let privateKey, publicKey;\n\n    if (keyObjectSupported) {\n      var _ref2 = await generateKeyPair('ec', {\n        namedCurve: crv\n      });\n\n      privateKey = _ref2.privateKey;\n      publicKey = _ref2.publicKey;\n      return privat ? privateKey : publicKey;\n    }\n\n    var _ref3 = await generateKeyPair('ec', {\n      namedCurve: crv,\n      publicKeyEncoding: {\n        type: 'spki',\n        format: 'pem'\n      },\n      privateKeyEncoding: {\n        type: 'pkcs8',\n        format: 'pem'\n      }\n    });\n\n    privateKey = _ref3.privateKey;\n    publicKey = _ref3.publicKey;\n\n    if (privat) {\n      return createPrivateKey(privateKey);\n    } else {\n      return createPublicKey(publicKey);\n    }\n  }\n\n  static generateSync(crv = 'P-256', privat = true) {\n    if (!EC_CURVES.has(crv)) {\n      throw new errors.JOSENotSupported(\"unsupported EC key curve: \".concat(crv));\n    }\n\n    if (crv === secp256k1 && crv !== 'secp256k1') {\n      crv = 'secp256k1';\n    }\n\n    let privateKey, publicKey;\n\n    if (keyObjectSupported) {\n      var _generateKeyPairSync = generateKeyPairSync('ec', {\n        namedCurve: crv\n      });\n\n      privateKey = _generateKeyPairSync.privateKey;\n      publicKey = _generateKeyPairSync.publicKey;\n      return privat ? privateKey : publicKey;\n    }\n\n    var _generateKeyPairSync2 = generateKeyPairSync('ec', {\n      namedCurve: crv,\n      publicKeyEncoding: {\n        type: 'spki',\n        format: 'pem'\n      },\n      privateKeyEncoding: {\n        type: 'pkcs8',\n        format: 'pem'\n      }\n    });\n\n    privateKey = _generateKeyPairSync2.privateKey;\n    publicKey = _generateKeyPairSync2.publicKey;\n\n    if (privat) {\n      return createPrivateKey(privateKey);\n    } else {\n      return createPublicKey(publicKey);\n    }\n  }\n\n}\n\nmodule.exports = ECKey;","map":null,"metadata":{},"sourceType":"script"}