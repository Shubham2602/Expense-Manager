{"ast":null,"code":"let _require = require('crypto'),\n    createPublicKey = _require.createPublicKey,\n    createPrivateKey = _require.createPrivateKey,\n    createSecretKey = _require.createSecretKey,\n    KeyObject = _require.KeyObject;\n\nconst _require2 = require('./runtime_support'),\n      keyObjectSupported = _require2.keyObjectSupported;\n\nlet asInput;\n\nif (!keyObjectSupported) {\n  const _require3 = require('os'),\n        EOL = _require3.EOL;\n\n  const errors = require('../errors');\n\n  const isObject = require('./is_object');\n\n  const asn1 = require('./asn1');\n\n  const toInput = Symbol('toInput');\n  const namedCurve = Symbol('namedCurve');\n  const map = new WeakMap();\n\n  const i = ctx => {\n    if (!map.has(ctx)) {\n      map.set(ctx, {});\n    }\n\n    return map.get(ctx);\n  };\n\n  asInput = (keyObject, needsPublic) => {\n    if (keyObject instanceof KeyObject) {\n      return keyObject[toInput](needsPublic);\n    }\n\n    return createSecretKey(keyObject)[toInput](needsPublic);\n  };\n\n  const pemToDer = pem => Buffer.from(pem.replace(/(?:-----(?:BEGIN|END)(?: (?:RSA|EC))? (?:PRIVATE|PUBLIC) KEY-----|\\s)/g, ''), 'base64');\n\n  const derToPem = (der, label) => \"-----BEGIN \".concat(label, \"-----\").concat(EOL).concat(der.toString('base64').match(/.{1,64}/g).join(EOL)).concat(EOL, \"-----END \").concat(label, \"-----\");\n\n  KeyObject = class KeyObject {\n    export({\n      cipher,\n      passphrase,\n      type,\n      format\n    } = {}) {\n      if (i(this).type === 'secret') {\n        return Buffer.from(i(this).buffer);\n      }\n\n      if (i(this).type === 'public') {\n        if (format !== 'pem' && format !== 'der') {\n          throw new TypeError('format must be one of \"pem\" or \"der\"');\n        }\n\n        if (this.asymmetricKeyType === 'rsa') {\n          switch (type) {\n            case 'pkcs1':\n              if (format === 'pem') {\n                return i(this).pem;\n              }\n\n              return pemToDer(i(this).pem);\n\n            case 'spki':\n              {\n                const PublicKeyInfo = asn1.get('PublicKeyInfo');\n                const pem = PublicKeyInfo.encode({\n                  algorithm: {\n                    algorithm: '1.2.840.113549.1.1.1'.split('.'),\n                    parameters: Buffer.from('BQA=', 'base64')\n                  },\n                  publicKey: {\n                    unused: 0,\n                    data: pemToDer(i(this).pem)\n                  }\n                }, 'pem', {\n                  label: 'PUBLIC KEY'\n                });\n                return format === 'pem' ? pem : pemToDer(pem);\n              }\n\n            default:\n              throw new TypeError('type must be one of \"pkcs1\" or \"spki\"');\n          }\n        }\n\n        if (this.asymmetricKeyType === 'ec') {\n          if (type !== 'spki') {\n            throw new TypeError('type must be \"spki\"');\n          }\n\n          if (format === 'pem') {\n            return i(this).pem;\n          }\n\n          return pemToDer(i(this).pem);\n        }\n      }\n\n      if (i(this).type === 'private') {\n        if (format !== 'pem' && format !== 'der') {\n          throw new TypeError('format must be one of \"pem\" or \"der\"');\n        }\n\n        if (passphrase !== undefined || cipher !== undefined) {\n          throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version');\n        }\n\n        if (type === 'pkcs8') {\n          if (i(this).pkcs8) {\n            if (format === 'der' && typeof i(this).pkcs8 === 'string') {\n              return pemToDer(i(this).pkcs8);\n            }\n\n            if (format === 'pem' && Buffer.isBuffer(i(this).pkcs8)) {\n              return derToPem(i(this).pkcs8, 'PRIVATE KEY');\n            }\n\n            return i(this).pkcs8;\n          }\n\n          if (this.asymmetricKeyType === 'rsa') {\n            const parsed = i(this).asn1;\n            const RSAPrivateKey = asn1.get('RSAPrivateKey');\n            const privateKey = RSAPrivateKey.encode(parsed);\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: '1.2.840.113549.1.1.1'.split('.'),\n                parameters: Buffer.from('BQA=', 'base64')\n              }\n            });\n            i(this).pkcs8 = pkcs8;\n            return this.export({\n              type,\n              format\n            });\n          }\n\n          if (this.asymmetricKeyType === 'ec') {\n            const parsed = i(this).asn1;\n            const ECPrivateKey = asn1.get('ECPrivateKey');\n            const privateKey = ECPrivateKey.encode({\n              version: parsed.version,\n              privateKey: parsed.privateKey,\n              publicKey: parsed.publicKey\n            });\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n            const OID = asn1.get('OID');\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: '1.2.840.10045.2.1'.split('.'),\n                parameters: OID.encode(i(this).asn1.parameters.value)\n              }\n            });\n            i(this).pkcs8 = pkcs8;\n            return this.export({\n              type,\n              format\n            });\n          }\n        }\n\n        if (this.asymmetricKeyType === 'rsa' && type === 'pkcs1') {\n          if (format === 'pem') {\n            return i(this).pem;\n          }\n\n          return pemToDer(i(this).pem);\n        } else if (this.asymmetricKeyType === 'ec' && type === 'sec1') {\n          if (format === 'pem') {\n            return i(this).pem;\n          }\n\n          return pemToDer(i(this).pem);\n        } else {\n          throw new TypeError(\"type must be one of \\\"spki\\\" or \\\"\".concat(this.asymmetricKeyType === 'rsa' ? 'pkcs1' : 'sec1', \"\\\"\"));\n        }\n      }\n    }\n\n    get type() {\n      return i(this).type;\n    }\n\n    get asymmetricKeyType() {\n      return i(this).asymmetricKeyType;\n    }\n\n    get symmetricKeySize() {\n      return i(this).symmetricKeySize;\n    }\n\n    [toInput](needsPublic) {\n      switch (i(this).type) {\n        case 'secret':\n          return i(this).buffer;\n\n        case 'public':\n          return i(this).pem;\n\n        default:\n          if (needsPublic) {\n            if (!('pub' in i(this))) {\n              i(this).pub = createPublicKey(this);\n            }\n\n            return i(this).pub[toInput](false);\n          }\n\n          return i(this).pem;\n      }\n    }\n\n  };\n\n  createSecretKey = buffer => {\n    if (!Buffer.isBuffer(buffer) || !buffer.length) {\n      throw new TypeError('input must be a non-empty Buffer instance');\n    }\n\n    const keyObject = new KeyObject();\n    i(keyObject).buffer = Buffer.from(buffer);\n    i(keyObject).symmetricKeySize = buffer.length;\n    i(keyObject).type = 'secret';\n    return keyObject;\n  };\n\n  createPublicKey = input => {\n    if (input instanceof KeyObject) {\n      if (input.type !== 'private') {\n        throw new TypeError('expected a private key');\n      }\n\n      switch (input.asymmetricKeyType) {\n        case 'ec':\n          {\n            const PublicKeyInfo = asn1.get('PublicKeyInfo');\n            const OID = asn1.get('OID');\n            const key = PublicKeyInfo.encode({\n              algorithm: {\n                algorithm: '1.2.840.10045.2.1'.split('.'),\n                parameters: OID.encode(i(input).asn1.parameters.value)\n              },\n              publicKey: i(input).asn1.publicKey\n            });\n            return createPublicKey({\n              key,\n              format: 'der',\n              type: 'spki'\n            });\n          }\n\n        case 'rsa':\n          {\n            const RSAPublicKey = asn1.get('RSAPublicKey');\n            const key = RSAPublicKey.encode(i(input).asn1);\n            return createPublicKey({\n              key,\n              format: 'der',\n              type: 'pkcs1'\n            });\n          }\n      }\n    }\n\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = {\n        key: input,\n        format: 'pem'\n      };\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object');\n    }\n\n    const _input = input,\n          format = _input.format;\n    let _input2 = input,\n        key = _input2.key,\n        type = _input2.type;\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer');\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"');\n    }\n\n    let label;\n\n    if (format === 'pem') {\n      key = key.toString();\n\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PUBLIC KEY-----':\n          type = 'spki';\n          label = 'PUBLIC KEY';\n          break;\n\n        case '-----BEGIN RSA PUBLIC KEY-----':\n          type = 'pkcs1';\n          label = 'RSA PUBLIC KEY';\n          break;\n\n        case '-----BEGIN CERTIFICATE-----':\n          throw new errors.JOSENotSupported('X.509 certificates are supported in your Node.js runtime version');\n\n        default:\n          throw new TypeError('unknown/unsupported PEM type');\n      }\n    }\n\n    switch (type) {\n      case 'spki':\n        {\n          const PublicKeyInfo = asn1.get('PublicKeyInfo');\n          const parsed = PublicKeyInfo.decode(key, format, {\n            label\n          });\n          let type, keyObject;\n\n          switch (parsed.algorithm.algorithm.join('.')) {\n            case '1.2.840.10045.2.1':\n              {\n                keyObject = new KeyObject();\n                i(keyObject).asn1 = parsed;\n                i(keyObject).asymmetricKeyType = 'ec';\n                i(keyObject).type = 'public';\n                i(keyObject).pem = PublicKeyInfo.encode(parsed, 'pem', {\n                  label: 'PUBLIC KEY'\n                });\n                break;\n              }\n\n            case '1.2.840.113549.1.1.1':\n              {\n                type = 'pkcs1';\n                keyObject = createPublicKey({\n                  type,\n                  key: parsed.publicKey.data,\n                  format: 'der'\n                });\n                break;\n              }\n\n            default:\n              throw new errors.JOSENotSupported(\"OID \".concat(parsed.algorithm.algorithm.join('.'), \" is not supported in your Node.js runtime version\"));\n          }\n\n          return keyObject;\n        }\n\n      case 'pkcs1':\n        {\n          const RSAPublicKey = asn1.get('RSAPublicKey');\n          const parsed = RSAPublicKey.decode(key, format, {\n            label\n          });\n          const keyObject = new KeyObject();\n          i(keyObject).asn1 = parsed;\n          i(keyObject).asymmetricKeyType = 'rsa';\n          i(keyObject).type = 'public';\n          i(keyObject).pem = RSAPublicKey.encode(parsed, 'pem', {\n            label: 'RSA PUBLIC KEY'\n          });\n          return keyObject;\n        }\n\n      default:\n        throw new TypeError('type must be one of \"pkcs1\" or \"spki\"');\n    }\n  };\n\n  createPrivateKey = (input, hints) => {\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = {\n        key: input,\n        format: 'pem'\n      };\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object');\n    }\n\n    const _input3 = input,\n          format = _input3.format,\n          passphrase = _input3.passphrase;\n    let _input4 = input,\n        key = _input4.key,\n        type = _input4.type;\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer');\n    }\n\n    if (passphrase !== undefined) {\n      throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version');\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"');\n    }\n\n    let label;\n\n    if (format === 'pem') {\n      key = key.toString();\n\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PRIVATE KEY-----':\n          type = 'pkcs8';\n          label = 'PRIVATE KEY';\n          break;\n\n        case '-----BEGIN EC PRIVATE KEY-----':\n          type = 'sec1';\n          label = 'EC PRIVATE KEY';\n          break;\n\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          type = 'pkcs1';\n          label = 'RSA PRIVATE KEY';\n          break;\n\n        default:\n          throw new TypeError('unknown/unsupported PEM type');\n      }\n    }\n\n    switch (type) {\n      case 'pkcs8':\n        {\n          const PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n          const parsed = PrivateKeyInfo.decode(key, format, {\n            label\n          });\n          let type, keyObject;\n\n          switch (parsed.algorithm.algorithm.join('.')) {\n            case '1.2.840.10045.2.1':\n              {\n                const OID = asn1.get('OID');\n                type = 'sec1';\n                keyObject = createPrivateKey({\n                  type,\n                  key: parsed.privateKey,\n                  format: 'der'\n                }, {\n                  [namedCurve]: OID.decode(parsed.algorithm.parameters)\n                });\n                break;\n              }\n\n            case '1.2.840.113549.1.1.1':\n              {\n                type = 'pkcs1';\n                keyObject = createPrivateKey({\n                  type,\n                  key: parsed.privateKey,\n                  format: 'der'\n                });\n                break;\n              }\n\n            default:\n              throw new errors.JOSENotSupported(\"OID \".concat(parsed.algorithm.algorithm.join('.'), \" is not supported in your Node.js runtime version\"));\n          }\n\n          i(keyObject).pkcs8 = key;\n          return keyObject;\n        }\n\n      case 'pkcs1':\n        {\n          const RSAPrivateKey = asn1.get('RSAPrivateKey');\n          const parsed = RSAPrivateKey.decode(key, format, {\n            label\n          });\n          const keyObject = new KeyObject();\n          i(keyObject).asn1 = parsed;\n          i(keyObject).asymmetricKeyType = 'rsa';\n          i(keyObject).type = 'private';\n          i(keyObject).pem = RSAPrivateKey.encode(parsed, 'pem', {\n            label: 'RSA PRIVATE KEY'\n          });\n          return keyObject;\n        }\n\n      case 'sec1':\n        {\n          const ECPrivateKey = asn1.get('ECPrivateKey');\n          let parsed = ECPrivateKey.decode(key, format, {\n            label\n          });\n\n          if (!('parameters' in parsed) && !hints[namedCurve]) {\n            throw new Error('invalid sec1');\n          } else if (!('parameters' in parsed)) {\n            parsed = { ...parsed,\n              parameters: {\n                type: 'namedCurve',\n                value: hints[namedCurve]\n              }\n            };\n          }\n\n          const keyObject = new KeyObject();\n          i(keyObject).asn1 = parsed;\n          i(keyObject).asymmetricKeyType = 'ec';\n          i(keyObject).type = 'private';\n          i(keyObject).pem = ECPrivateKey.encode(parsed, 'pem', {\n            label: 'EC PRIVATE KEY'\n          });\n          return keyObject;\n        }\n\n      default:\n        throw new TypeError('type must be one of \"pkcs8\", \"pkcs1\" or \"sec1\"');\n    }\n  };\n} else {\n  asInput = input => input;\n}\n\nmodule.exports = {\n  createPublicKey,\n  createPrivateKey,\n  createSecretKey,\n  KeyObject,\n  asInput\n};","map":null,"metadata":{},"sourceType":"script"}