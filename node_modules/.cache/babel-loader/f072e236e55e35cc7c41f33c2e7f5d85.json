{"ast":null,"code":"/* eslint-disable max-classes-per-file */\nconst _require = require('util'),\n      inspect = _require.inspect;\n\nconst stdhttp = require('http');\n\nconst crypto = require('crypto');\n\nconst _require2 = require('assert'),\n      assert = _require2.strict;\n\nconst querystring = require('querystring');\n\nconst url = require('url');\n\nconst jose = require('jose');\n\nconst base64url = require('base64url');\n\nconst defaultsDeep = require('lodash/defaultsDeep');\n\nconst defaults = require('lodash/defaults');\n\nconst merge = require('lodash/merge');\n\nconst isPlainObject = require('lodash/isPlainObject');\n\nconst tokenHash = require('oidc-token-hash');\n\nconst _require3 = require('./helpers/assert'),\n      assertSigningAlgValuesSupport = _require3.assertSigningAlgValuesSupport,\n      assertIssuerConfiguration = _require3.assertIssuerConfiguration;\n\nconst pick = require('./helpers/pick');\n\nconst processResponse = require('./helpers/process_response');\n\nconst TokenSet = require('./token_set');\n\nconst _require4 = require('./errors'),\n      OPError = _require4.OPError,\n      RPError = _require4.RPError;\n\nconst now = require('./helpers/unix_timestamp');\n\nconst _require5 = require('./helpers/generators'),\n      random = _require5.random;\n\nconst request = require('./helpers/request');\n\nconst _require6 = require('./helpers/consts'),\n      CALLBACK_PROPERTIES = _require6.CALLBACK_PROPERTIES,\n      CLIENT_DEFAULTS = _require6.CLIENT_DEFAULTS,\n      JWT_CONTENT = _require6.JWT_CONTENT,\n      CLOCK_TOLERANCE = _require6.CLOCK_TOLERANCE;\n\nconst issuerRegistry = require('./issuer_registry');\n\nconst instance = require('./helpers/weak_cache');\n\nconst _require7 = require('./helpers/client'),\n      authenticatedPost = _require7.authenticatedPost,\n      resolveResponseType = _require7.resolveResponseType,\n      resolveRedirectUri = _require7.resolveRedirectUri;\n\nconst DeviceFlowHandle = require('./device_flow_handle');\n\nfunction pickCb(input) {\n  return pick(input, ...CALLBACK_PROPERTIES);\n}\n\nfunction authorizationHeaderValue(token, tokenType = 'Bearer') {\n  return \"\".concat(tokenType, \" \").concat(token);\n}\n\nfunction cleanUpClaims(claims) {\n  if (Object.keys(claims._claim_names).length === 0) {\n    delete claims._claim_names;\n  }\n\n  if (Object.keys(claims._claim_sources).length === 0) {\n    delete claims._claim_sources;\n  }\n}\n\nfunction assignClaim(target, source, sourceName, throwOnMissing = true) {\n  return ([claim, inSource]) => {\n    if (inSource === sourceName) {\n      if (throwOnMissing && source[claim] === undefined) {\n        throw new RPError(\"expected claim \\\"\".concat(claim, \"\\\" in \\\"\").concat(sourceName, \"\\\"\"));\n      } else if (source[claim] !== undefined) {\n        target[claim] = source[claim];\n      }\n\n      delete target._claim_names[claim];\n    }\n  };\n}\n\nfunction getFromJWT(jwt, position, claim) {\n  if (typeof jwt !== 'string') {\n    throw new RPError({\n      message: \"invalid JWT type, expected a string, got: \".concat(typeof jwt),\n      jwt\n    });\n  }\n\n  const parts = jwt.split('.');\n\n  if (parts.length !== 3) {\n    throw new RPError({\n      message: 'invalid JWT format, expected three parts',\n      jwt\n    });\n  }\n\n  const parsed = JSON.parse(base64url.decode(parts[position]));\n  return typeof claim === 'undefined' ? parsed : parsed[claim];\n}\n\nfunction getSub(jwt) {\n  return getFromJWT(jwt, 1, 'sub');\n}\n\nfunction getIss(jwt) {\n  return getFromJWT(jwt, 1, 'iss');\n}\n\nfunction getHeader(jwt) {\n  return getFromJWT(jwt, 0);\n}\n\nfunction getPayload(jwt) {\n  return getFromJWT(jwt, 1);\n}\n\nfunction verifyPresence(payload, jwt, prop) {\n  if (payload[prop] === undefined) {\n    throw new RPError({\n      message: \"missing required JWT property \".concat(prop),\n      jwt\n    });\n  }\n}\n\nfunction authorizationParams(params) {\n  const authParams = {\n    client_id: this.client_id,\n    scope: 'openid',\n    response_type: resolveResponseType.call(this),\n    redirect_uri: resolveRedirectUri.call(this),\n    ...params\n  };\n  Object.entries(authParams).forEach(([key, value]) => {\n    if (value === null || value === undefined) {\n      delete authParams[key];\n    } else if (key === 'claims' && typeof value === 'object') {\n      authParams[key] = JSON.stringify(value);\n    } else if (key === 'resource' && Array.isArray(value)) {\n      authParams[key] = value;\n    } else if (typeof value !== 'string') {\n      authParams[key] = String(value);\n    }\n  });\n\n  if (authParams.response_type && authParams.response_type.split(' ').includes('id_token') && !authParams.nonce) {\n    throw new TypeError('nonce MUST be provided for implicit and hybrid flows');\n  }\n\n  return authParams;\n}\n\nasync function claimJWT(jwt) {\n  const iss = getIss(jwt);\n  const keyDef = getHeader(jwt);\n\n  if (!keyDef.alg) {\n    throw new RPError({\n      message: 'claim source is missing JWT header alg property',\n      jwt\n    });\n  }\n\n  if (keyDef.alg === 'none') {\n    return getPayload(jwt);\n  }\n\n  let key;\n\n  if (!iss || iss === this.issuer.issuer) {\n    key = await this.issuer.key(keyDef);\n  } else if (issuerRegistry.has(iss)) {\n    key = await issuerRegistry.get(iss).key(keyDef);\n  } else {\n    const discovered = await this.issuer.constructor.discover(iss);\n    key = await discovered.key(keyDef);\n  }\n\n  return jose.JWS.verify(jwt, key);\n}\n\nfunction getKeystore(jwks) {\n  const keystore = jose.JWKS.asKeyStore(jwks);\n\n  if (keystore.all().some(key => key.type !== 'private')) {\n    throw new TypeError('jwks must only contain private keys');\n  }\n\n  return keystore;\n} // if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead\n// this is in place to take care of most common pitfalls when first using discovered Issuers without\n// the support for default values defined by Discovery 1.0\n\n\nfunction checkBasicSupport(client, metadata, properties) {\n  try {\n    const supported = client.issuer.token_endpoint_auth_methods_supported;\n\n    if (!supported.includes(properties.token_endpoint_auth_method)) {\n      if (supported.includes('client_secret_post')) {\n        properties.token_endpoint_auth_method = 'client_secret_post';\n      }\n    }\n  } catch (err) {}\n}\n\nfunction handleCommonMistakes(client, metadata, properties) {\n  if (!metadata.token_endpoint_auth_method) {\n    // if no explicit value was provided\n    checkBasicSupport(client, metadata, properties);\n  } // :fp: c'mon people... RTFM\n\n\n  if (metadata.redirect_uri) {\n    if (metadata.redirect_uris) {\n      throw new TypeError('provide a redirect_uri or redirect_uris, not both');\n    }\n\n    properties.redirect_uris = [metadata.redirect_uri];\n    delete properties.redirect_uri;\n  }\n\n  if (metadata.response_type) {\n    if (metadata.response_types) {\n      throw new TypeError('provide a response_type or response_types, not both');\n    }\n\n    properties.response_types = [metadata.response_type];\n    delete properties.response_type;\n  }\n}\n\nfunction getDefaultsForEndpoint(endpoint, issuer, properties) {\n  if (!issuer[\"\".concat(endpoint, \"_endpoint\")]) return;\n  const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;\n  const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;\n  const eam = \"\".concat(endpoint, \"_endpoint_auth_method\");\n  const easa = \"\".concat(endpoint, \"_endpoint_auth_signing_alg\");\n\n  if (properties[eam] === undefined && properties[easa] === undefined) {\n    if (tokenEndpointAuthMethod !== undefined) {\n      properties[eam] = tokenEndpointAuthMethod;\n    }\n\n    if (tokenEndpointAuthSigningAlg !== undefined) {\n      properties[easa] = tokenEndpointAuthSigningAlg;\n    }\n  }\n}\n\nclass BaseClient {}\n\nmodule.exports = (issuer, aadIssValidation = false) => class Client extends BaseClient {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(metadata = {}, jwks) {\n    super();\n\n    if (typeof metadata.client_id !== 'string' || !metadata.client_id) {\n      throw new TypeError('client_id is required');\n    }\n\n    const properties = { ...CLIENT_DEFAULTS,\n      ...metadata\n    };\n    handleCommonMistakes(this, metadata, properties);\n    assertSigningAlgValuesSupport('token', this.issuer, properties);\n    ['introspection', 'revocation'].forEach(endpoint => {\n      getDefaultsForEndpoint(endpoint, this.issuer, properties);\n      assertSigningAlgValuesSupport(endpoint, this.issuer, properties);\n    });\n    Object.entries(properties).forEach(([key, value]) => {\n      instance(this).get('metadata').set(key, value);\n\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return instance(this).get('metadata').get(key);\n          },\n\n          enumerable: true\n        });\n      }\n    });\n\n    if (jwks !== undefined) {\n      const keystore = getKeystore.call(this, jwks);\n      instance(this).set('keystore', keystore);\n    }\n\n    this[CLOCK_TOLERANCE] = 0;\n  }\n  /**\n   * @name authorizationUrl\n   * @api public\n   */\n\n\n  authorizationUrl(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n\n    assertIssuerConfiguration(this.issuer, 'authorization_endpoint');\n    const target = url.parse(this.issuer.authorization_endpoint, true);\n    target.search = null;\n    target.query = { ...target.query,\n      ...authorizationParams.call(this, params)\n    };\n    return url.format(target);\n  }\n  /**\n   * @name authorizationPost\n   * @api public\n   */\n\n\n  authorizationPost(params = {}) {\n    if (!isPlainObject(params)) {\n      throw new TypeError('params must be a plain object');\n    }\n\n    const inputs = authorizationParams.call(this, params);\n    const formInputs = Object.keys(inputs).map(name => \"<input type=\\\"hidden\\\" name=\\\"\".concat(name, \"\\\" value=\\\"\").concat(inputs[name], \"\\\"/>\")).join('\\n');\n    return \"<!DOCTYPE html>\\n<head>\\n  <title>Requesting Authorization</title>\\n</head>\\n<body onload=\\\"javascript:document.forms[0].submit()\\\">\\n  <form method=\\\"post\\\" action=\\\"\".concat(this.issuer.authorization_endpoint, \"\\\">\\n    \").concat(formInputs, \"\\n  </form>\\n</body>\\n</html>\");\n  }\n  /**\n   * @name endSessionUrl\n   * @api public\n   */\n\n\n  endSessionUrl(params = {}) {\n    assertIssuerConfiguration(this.issuer, 'end_session_endpoint');\n\n    const _ref = this.post_logout_redirect_uris || [],\n          postLogout = _ref[0],\n          length = _ref.length;\n\n    const _params$post_logout_r = params.post_logout_redirect_uri,\n          post_logout_redirect_uri = _params$post_logout_r === void 0 ? length === 1 ? postLogout : undefined : _params$post_logout_r;\n    let hint = params.id_token_hint;\n\n    if (hint instanceof TokenSet) {\n      if (!hint.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n\n      hint = hint.id_token;\n    }\n\n    const target = url.parse(this.issuer.end_session_endpoint, true);\n    target.search = null;\n    target.query = { ...params,\n      ...target.query,\n      ...{\n        post_logout_redirect_uri,\n        id_token_hint: hint\n      }\n    };\n    Object.entries(target.query).forEach(([key, value]) => {\n      if (value === null || value === undefined) {\n        delete target.query[key];\n      }\n    });\n    return url.format(target);\n  }\n  /**\n   * @name callbackParams\n   * @api public\n   */\n\n\n  callbackParams(input) {\n    // eslint-disable-line class-methods-use-this\n    const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;\n    const isString = typeof input === 'string';\n\n    if (!isString && !isIncomingMessage) {\n      throw new TypeError('#callbackParams only accepts string urls, http.IncomingMessage or a lookalike');\n    }\n\n    if (isIncomingMessage) {\n      switch (input.method) {\n        case 'GET':\n          return pickCb(url.parse(input.url, true).query);\n\n        case 'POST':\n          if (input.body === undefined) {\n            throw new TypeError('incoming message body missing, include a body parser prior to this method call');\n          }\n\n          switch (typeof input.body) {\n            case 'object':\n            case 'string':\n              if (Buffer.isBuffer(input.body)) {\n                return pickCb(querystring.parse(input.body.toString('utf-8')));\n              }\n\n              if (typeof input.body === 'string') {\n                return pickCb(querystring.parse(input.body));\n              }\n\n              return pickCb(input.body);\n\n            default:\n              throw new TypeError('invalid IncomingMessage body object');\n          }\n\n        default:\n          throw new TypeError('invalid IncomingMessage method');\n      }\n    } else {\n      return pickCb(url.parse(input, true).query);\n    }\n  }\n  /**\n   * @name callback\n   * @api public\n   */\n\n\n  async callback(redirectUri, parameters, checks = {}, {\n    exchangeBody,\n    clientAssertionPayload\n  } = {}) {\n    const params = pickCb(parameters);\n\n    if (this.default_max_age && !checks.max_age) {\n      checks.max_age = this.default_max_age;\n    }\n\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params\n      });\n    }\n\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params\n      });\n    }\n\n    if (params.error) {\n      throw new OPError(params);\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      id_token: ['id_token'],\n      token: ['access_token', 'token_type']\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params\n            });\n          }\n        } else {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              throw new RPError({\n                message: \"\".concat(param, \" missing from response\"),\n                checks,\n                params\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (params.id_token) {\n      const tokenset = new TokenSet(params);\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'authorization', checks.max_age, checks.state);\n\n      if (!params.code) {\n        return tokenset;\n      }\n    }\n\n    if (params.code) {\n      const tokenset = await this.grant({ ...exchangeBody,\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier\n      }, {\n        clientAssertionPayload\n      });\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, checks.nonce, 'token', checks.max_age);\n\n      if (params.session_state) {\n        tokenset.session_state = params.session_state;\n      }\n\n      return tokenset;\n    }\n\n    return new TokenSet(params);\n  }\n  /**\n   * @name oauthCallback\n   * @api public\n   */\n\n\n  async oauthCallback(redirectUri, parameters, checks = {}, {\n    exchangeBody,\n    clientAssertionPayload\n  } = {}) {\n    const params = pickCb(parameters);\n\n    if (params.state && !checks.state) {\n      throw new TypeError('checks.state argument is missing');\n    }\n\n    if (!params.state && checks.state) {\n      throw new RPError({\n        message: 'state missing from the response',\n        checks,\n        params\n      });\n    }\n\n    if (checks.state !== params.state) {\n      throw new RPError({\n        printf: ['state mismatch, expected %s, got: %s', checks.state, params.state],\n        checks,\n        params\n      });\n    }\n\n    if (params.error) {\n      throw new OPError(params);\n    }\n\n    const RESPONSE_TYPE_REQUIRED_PARAMS = {\n      code: ['code'],\n      token: ['access_token', 'token_type']\n    };\n\n    if (checks.response_type) {\n      for (const type of checks.response_type.split(' ')) {\n        // eslint-disable-line no-restricted-syntax\n        if (type === 'none') {\n          if (params.code || params.id_token || params.access_token) {\n            throw new RPError({\n              message: 'unexpected params encountered for \"none\" response',\n              checks,\n              params\n            });\n          }\n        }\n\n        if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n          for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]) {\n            // eslint-disable-line no-restricted-syntax, max-len\n            if (!params[param]) {\n              throw new RPError({\n                message: \"\".concat(param, \" missing from response\"),\n                checks,\n                params\n              });\n            }\n          }\n        }\n      }\n    }\n\n    if (params.code) {\n      return this.grant({ ...exchangeBody,\n        grant_type: 'authorization_code',\n        code: params.code,\n        redirect_uri: redirectUri,\n        code_verifier: checks.code_verifier\n      }, {\n        clientAssertionPayload\n      });\n    }\n\n    return new TokenSet(params);\n  }\n  /**\n   * @name decryptIdToken\n   * @api private\n   */\n\n\n  async decryptIdToken(token, use) {\n    if (!use) use = 'id_token'; // eslint-disable-line no-param-reassign\n\n    if (!this[\"\".concat(use, \"_encrypted_response_alg\")]) {\n      return token;\n    }\n\n    let idToken = token;\n\n    if (idToken instanceof TokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n\n      idToken = idToken.id_token;\n    }\n\n    const expectedAlg = this[\"\".concat(use, \"_encrypted_response_alg\")];\n    const expectedEnc = this[\"\".concat(use, \"_encrypted_response_enc\")];\n    const header = JSON.parse(base64url.decode(idToken.split('.')[0]));\n\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWE alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt: idToken\n      });\n    }\n\n    if (header.enc !== expectedEnc) {\n      throw new RPError({\n        printf: ['unexpected JWE enc received, expected %s, got: %s', expectedEnc, header.enc],\n        jwt: idToken\n      });\n    }\n\n    let keyOrStore;\n\n    if (expectedAlg.match(/^(?:RSA|ECDH)/)) {\n      keyOrStore = instance(this).get('keystore');\n    } else {\n      keyOrStore = await this.joseSecret(expectedAlg === 'dir' ? expectedEnc : expectedAlg);\n    }\n\n    const payload = jose.JWE.decrypt(idToken, keyOrStore);\n    const result = payload.toString('utf8');\n\n    if (token instanceof TokenSet) {\n      token.id_token = result;\n      return token;\n    }\n\n    return result;\n  }\n  /**\n   * @name validateIdToken\n   * @api private\n   */\n\n\n  async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {\n    let idToken = tokenSet;\n    const expectedAlg = returnedBy === 'userinfo' ? this.userinfo_signed_response_alg : this.id_token_signed_response_alg;\n    const isTokenSet = idToken instanceof TokenSet;\n\n    if (isTokenSet) {\n      if (!idToken.id_token) {\n        throw new TypeError('id_token not present in TokenSet');\n      }\n\n      idToken = idToken.id_token;\n    }\n\n    idToken = String(idToken);\n    const timestamp = now();\n    const parts = idToken.split('.');\n    const header = JSON.parse(base64url.decode(parts[0]));\n    const payload = JSON.parse(base64url.decode(parts[1]));\n\n    if (header.alg !== expectedAlg) {\n      throw new RPError({\n        printf: ['unexpected JWT alg received, expected %s, got: %s', expectedAlg, header.alg],\n        jwt: idToken\n      });\n    }\n\n    if (returnedBy !== 'userinfo') {\n      ['iss', 'sub', 'aud', 'exp', 'iat'].forEach(verifyPresence.bind(undefined, payload, idToken));\n    }\n\n    if (payload.iss !== undefined) {\n      let expectedIss = this.issuer.issuer;\n\n      if (aadIssValidation) {\n        expectedIss = this.issuer.issuer.replace('{tenantid}', payload.tid);\n      }\n\n      if (payload.iss !== expectedIss) {\n        throw new RPError({\n          printf: ['unexpected iss value, expected %s, got: %s', expectedIss, payload.iss],\n          jwt: idToken\n        });\n      }\n    }\n\n    if (payload.iat !== undefined) {\n      if (!Number.isInteger(payload.iat)) {\n        throw new RPError({\n          message: 'JWT iat claim must be a JSON number integer',\n          jwt: idToken\n        });\n      }\n\n      if (payload.iat > timestamp + this[CLOCK_TOLERANCE]) {\n        throw new RPError({\n          printf: ['id_token issued in the future, now %i, iat %i', timestamp + this[CLOCK_TOLERANCE], payload.iat],\n          jwt: idToken\n        });\n      }\n    }\n\n    if (payload.nbf !== undefined) {\n      if (!Number.isInteger(payload.nbf)) {\n        throw new RPError({\n          message: 'JWT nbf claim must be a JSON number integer',\n          jwt: idToken\n        });\n      }\n\n      if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {\n        throw new RPError({\n          printf: ['id_token not active yet, now %i, nbf %i', timestamp + this[CLOCK_TOLERANCE], payload.nbf],\n          jwt: idToken\n        });\n      }\n    }\n\n    if (maxAge || maxAge !== null && this.require_auth_time) {\n      if (!payload.auth_time) {\n        throw new RPError({\n          message: 'missing required JWT property auth_time',\n          jwt: idToken\n        });\n      }\n\n      if (!Number.isInteger(payload.auth_time)) {\n        throw new RPError({\n          message: 'JWT auth_time claim must be a JSON number integer',\n          jwt: idToken\n        });\n      }\n    }\n\n    if (maxAge && payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]) {\n      throw new RPError({\n        printf: ['too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i', maxAge, payload.auth_time, timestamp - this[CLOCK_TOLERANCE]],\n        jwt: idToken\n      });\n    }\n\n    if (nonce !== null && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {\n      throw new RPError({\n        printf: ['nonce mismatch, expected %s, got: %s', nonce, payload.nonce],\n        jwt: idToken\n      });\n    }\n\n    if (payload.exp !== undefined) {\n      if (!Number.isInteger(payload.exp)) {\n        throw new RPError({\n          message: 'JWT exp claim must be a JSON number integer',\n          jwt: idToken\n        });\n      }\n\n      if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {\n        throw new RPError({\n          printf: ['id_token expired, now %i, exp %i', timestamp - this[CLOCK_TOLERANCE], payload.exp],\n          jwt: idToken\n        });\n      }\n    }\n\n    if (payload.aud !== undefined) {\n      if (Array.isArray(payload.aud)) {\n        if (payload.aud.length > 1 && !payload.azp) {\n          throw new RPError({\n            message: 'missing required JWT property azp',\n            jwt: idToken\n          });\n        }\n\n        if (!payload.aud.includes(this.client_id)) {\n          throw new RPError({\n            printf: ['aud is missing the client_id, expected %s to be included in %j', this.client_id, payload.aud],\n            jwt: idToken\n          });\n        }\n      } else if (payload.aud !== this.client_id) {\n        throw new RPError({\n          printf: ['aud mismatch, expected %s, got: %s', this.client_id, payload.aud],\n          jwt: idToken\n        });\n      }\n    }\n\n    if (payload.azp !== undefined && payload.azp !== this.client_id) {\n      throw new RPError({\n        printf: ['azp must be the client_id, expected %s, got: %s', this.client_id, payload.azp],\n        jwt: idToken\n      });\n    }\n\n    let key;\n\n    if (header.alg.startsWith('HS')) {\n      key = await this.joseSecret();\n    } else if (header.alg !== 'none') {\n      key = await this.issuer.key(header);\n    }\n\n    if (returnedBy === 'authorization') {\n      if (!payload.at_hash && tokenSet.access_token) {\n        throw new RPError({\n          message: 'missing required property at_hash',\n          jwt: idToken\n        });\n      }\n\n      if (!payload.c_hash && tokenSet.code) {\n        throw new RPError({\n          message: 'missing required property c_hash',\n          jwt: idToken\n        });\n      }\n\n      if (payload.s_hash) {\n        if (!state) {\n          throw new TypeError('cannot verify s_hash, \"checks.state\" property not provided');\n        }\n\n        try {\n          tokenHash.validate({\n            claim: 's_hash',\n            source: 'state'\n          }, payload.s_hash, state, header.alg, key && key.crv);\n        } catch (err) {\n          throw new RPError({\n            message: err.message,\n            jwt: idToken\n          });\n        }\n      }\n    }\n\n    if (tokenSet.access_token && payload.at_hash !== undefined) {\n      try {\n        tokenHash.validate({\n          claim: 'at_hash',\n          source: 'access_token'\n        }, payload.at_hash, tokenSet.access_token, header.alg, key && key.crv);\n      } catch (err) {\n        throw new RPError({\n          message: err.message,\n          jwt: idToken\n        });\n      }\n    }\n\n    if (tokenSet.code && payload.c_hash !== undefined) {\n      try {\n        tokenHash.validate({\n          claim: 'c_hash',\n          source: 'code'\n        }, payload.c_hash, tokenSet.code, header.alg, key && key.crv);\n      } catch (err) {\n        throw new RPError({\n          message: err.message,\n          jwt: idToken\n        });\n      }\n    }\n\n    if (header.alg === 'none') {\n      return tokenSet;\n    }\n\n    try {\n      jose.JWS.verify(idToken, key);\n    } catch (err) {\n      throw new RPError({\n        message: 'failed to validate JWT signature',\n        jwt: idToken\n      });\n    }\n\n    return tokenSet;\n  }\n  /**\n   * @name refresh\n   * @api public\n   */\n\n\n  async refresh(refreshToken, {\n    exchangeBody,\n    clientAssertionPayload\n  } = {}) {\n    let token = refreshToken;\n\n    if (token instanceof TokenSet) {\n      if (!token.refresh_token) {\n        throw new TypeError('refresh_token not present in TokenSet');\n      }\n\n      token = token.refresh_token;\n    }\n\n    const tokenset = await this.grant({ ...exchangeBody,\n      grant_type: 'refresh_token',\n      refresh_token: String(token)\n    }, {\n      clientAssertionPayload\n    });\n\n    if (tokenset.id_token) {\n      await this.decryptIdToken(tokenset);\n      await this.validateIdToken(tokenset, null, 'token', null);\n    }\n\n    return tokenset;\n  }\n  /**\n   * @name userinfo\n   * @api public\n   */\n\n\n  async userinfo(accessToken, options) {\n    assertIssuerConfiguration(this.issuer, 'userinfo_endpoint');\n    let token = accessToken;\n    const opts = merge({\n      verb: 'GET',\n      via: 'header'\n    }, options);\n\n    if (token instanceof TokenSet) {\n      if (!token.access_token) {\n        throw new TypeError('access_token not present in TokenSet');\n      }\n\n      opts.tokenType = opts.tokenType || token.token_type;\n      token = token.access_token;\n    }\n\n    const verb = String(opts.verb).toUpperCase();\n    let requestOpts;\n\n    switch (opts.via) {\n      case 'query':\n        if (verb !== 'GET') {\n          throw new TypeError('providers should only parse query strings for GET requests');\n        }\n\n        requestOpts = {\n          query: {\n            access_token: token\n          }\n        };\n        break;\n\n      case 'body':\n        if (verb !== 'POST') {\n          throw new TypeError('can only send body on POST');\n        }\n\n        requestOpts = {\n          form: true,\n          body: {\n            access_token: token\n          }\n        };\n        break;\n\n      default:\n        requestOpts = {\n          headers: {\n            Authorization: authorizationHeaderValue(token, opts.tokenType)\n          }\n        };\n    }\n\n    if (opts.params) {\n      if (verb === 'POST') {\n        defaultsDeep(requestOpts, {\n          body: opts.params\n        });\n      } else {\n        defaultsDeep(requestOpts, {\n          query: opts.params\n        });\n      }\n    }\n\n    const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg || this.userinfo_encrypted_response_enc);\n\n    if (jwt) {\n      defaultsDeep(requestOpts, {\n        headers: {\n          Accept: 'application/jwt'\n        }\n      });\n    }\n\n    const mTLS = !!this.tls_client_certificate_bound_access_tokens;\n    let targetUrl;\n\n    if (mTLS) {\n      try {\n        targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;\n      } catch (err) {}\n    }\n\n    targetUrl = targetUrl || this.issuer.userinfo_endpoint;\n    const response = await request.call(this, { ...requestOpts,\n      method: verb,\n      url: targetUrl,\n      json: !jwt\n    }, {\n      mTLS\n    });\n    let parsed = processResponse(response, {\n      bearer: true\n    });\n\n    if (jwt) {\n      if (!JWT_CONTENT.test(response.headers['content-type'])) {\n        throw new RPError({\n          message: 'expected application/jwt response from the userinfo_endpoint',\n          response\n        });\n      }\n\n      const userinfo = await this.decryptIdToken(response.body, 'userinfo');\n\n      if (!this.userinfo_signed_response_alg) {\n        try {\n          parsed = JSON.parse(userinfo);\n          assert(isPlainObject(parsed));\n        } catch (err) {\n          throw new RPError({\n            message: 'failed to parse userinfo JWE payload as JSON',\n            jwt: userinfo\n          });\n        }\n      } else {\n        await this.validateIdToken(userinfo, null, 'userinfo', null);\n        parsed = JSON.parse(base64url.decode(userinfo.split('.')[1]));\n      }\n    }\n\n    if (accessToken.id_token) {\n      const expectedSub = getSub(accessToken.id_token);\n\n      if (parsed.sub !== expectedSub) {\n        throw new RPError({\n          printf: ['userinfo sub mismatch, expected %s, got: %s', expectedSub, parsed.sub],\n          body: parsed,\n          jwt: accessToken.id_token\n        });\n      }\n    }\n\n    return parsed;\n  }\n  /**\n   * @name derivedKey\n   * @api private\n   */\n\n\n  async derivedKey(len) {\n    const cacheKey = \"\".concat(len, \"_key\");\n\n    if (instance(this).has(cacheKey)) {\n      return instance(this).get(cacheKey);\n    }\n\n    const derivedBuffer = crypto.createHash('sha256').update(this.client_secret).digest().slice(0, len / 8);\n    const key = jose.JWK.asKey({\n      k: base64url.encode(derivedBuffer),\n      kty: 'oct'\n    });\n    instance(this).set(cacheKey, key);\n    return key;\n  }\n  /**\n   * @name joseSecret\n   * @api private\n   */\n\n\n  async joseSecret(alg) {\n    if (!this.client_secret) {\n      throw new TypeError('client_secret is required');\n    }\n\n    if (/^A(\\d{3})(?:GCM)?KW$/.test(alg)) {\n      return this.derivedKey(parseInt(RegExp.$1, 10));\n    }\n\n    if (/^A(\\d{3})(?:GCM|CBC-HS(\\d{3}))$/.test(alg)) {\n      return this.derivedKey(parseInt(RegExp.$2 || RegExp.$1, 10));\n    }\n\n    if (instance(this).has('jose_secret')) {\n      return instance(this).get('jose_secret');\n    }\n\n    const key = jose.JWK.asKey({\n      k: base64url.encode(this.client_secret),\n      kty: 'oct'\n    });\n    instance(this).set('jose_secret', key);\n    return key;\n  }\n  /**\n   * @name grant\n   * @api public\n   */\n\n\n  async grant(body, {\n    clientAssertionPayload\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    const response = await authenticatedPost.call(this, 'token', {\n      form: true,\n      body,\n      json: true\n    }, {\n      clientAssertionPayload\n    });\n    const responseBody = processResponse(response);\n    return new TokenSet(responseBody);\n  }\n  /**\n   * @name deviceAuthorization\n   * @api public\n   */\n\n\n  async deviceAuthorization(params = {}, {\n    exchangeBody,\n    clientAssertionPayload\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'device_authorization_endpoint');\n    assertIssuerConfiguration(this.issuer, 'token_endpoint');\n    const body = authorizationParams.call(this, {\n      client_id: this.client_id,\n      redirect_uri: null,\n      response_type: null,\n      ...params\n    });\n    const response = await authenticatedPost.call(this, 'device_authorization', {\n      form: true,\n      body,\n      json: true\n    }, {\n      clientAssertionPayload,\n      endpointAuthMethod: 'token'\n    });\n    const responseBody = processResponse(response);\n    return new DeviceFlowHandle({\n      client: this,\n      exchangeBody,\n      clientAssertionPayload,\n      response: responseBody,\n      maxAge: params.max_age\n    });\n  }\n  /**\n   * @name revoke\n   * @api public\n   */\n\n\n  async revoke(token, hint, {\n    revokeBody,\n    clientAssertionPayload\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'revocation_endpoint');\n\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n\n    const body = { ...revokeBody,\n      token\n    };\n\n    if (hint) {\n      body.token_type_hint = hint;\n    }\n\n    const response = await authenticatedPost.call(this, 'revocation', {\n      body,\n      form: true\n    }, {\n      clientAssertionPayload\n    });\n    processResponse(response, {\n      body: false\n    });\n  }\n  /**\n   * @name introspect\n   * @api public\n   */\n\n\n  async introspect(token, hint, {\n    introspectBody,\n    clientAssertionPayload\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'introspection_endpoint');\n\n    if (hint !== undefined && typeof hint !== 'string') {\n      throw new TypeError('hint must be a string');\n    }\n\n    const body = { ...introspectBody,\n      token\n    };\n\n    if (hint) {\n      body.token_type_hint = hint;\n    }\n\n    const response = await authenticatedPost.call(this, 'introspection', {\n      body,\n      form: true,\n      json: true\n    }, {\n      clientAssertionPayload\n    });\n    const responseBody = processResponse(response);\n    return responseBody;\n  }\n  /**\n   * @name fetchDistributedClaims\n   * @api public\n   */\n\n\n  async fetchDistributedClaims(claims, tokens = {}) {\n    if (!isPlainObject(claims)) {\n      throw new TypeError('claims argument must be a plain object');\n    }\n\n    if (!isPlainObject(claims._claim_sources)) {\n      return claims;\n    }\n\n    if (!isPlainObject(claims._claim_names)) {\n      return claims;\n    }\n\n    const distributedSources = Object.entries(claims._claim_sources).filter(([, value]) => value && value.endpoint);\n    await Promise.all(distributedSources.map(async ([sourceName, def]) => {\n      try {\n        const requestOpts = {\n          headers: {\n            Accept: 'application/jwt',\n            Authorization: authorizationHeaderValue(def.access_token || tokens[sourceName])\n          }\n        };\n        const response = await request.call(this, { ...requestOpts,\n          method: 'GET',\n          url: def.endpoint\n        });\n        const body = processResponse(response, {\n          bearer: true\n        });\n        const decoded = await claimJWT.call(this, body);\n        delete claims._claim_sources[sourceName];\n        Object.entries(claims._claim_names).forEach(assignClaim(claims, decoded, sourceName, false));\n      } catch (err) {\n        err.src = sourceName;\n        throw err;\n      }\n    }));\n    cleanUpClaims(claims);\n    return claims;\n  }\n  /**\n   * @name unpackAggregatedClaims\n   * @api public\n   */\n\n\n  async unpackAggregatedClaims(claims) {\n    if (!isPlainObject(claims)) {\n      throw new TypeError('claims argument must be a plain object');\n    }\n\n    if (!isPlainObject(claims._claim_sources)) {\n      return claims;\n    }\n\n    if (!isPlainObject(claims._claim_names)) {\n      return claims;\n    }\n\n    const aggregatedSources = Object.entries(claims._claim_sources).filter(([, value]) => value && value.JWT);\n    await Promise.all(aggregatedSources.map(async ([sourceName, def]) => {\n      try {\n        const decoded = await claimJWT.call(this, def.JWT);\n        delete claims._claim_sources[sourceName];\n        Object.entries(claims._claim_names).forEach(assignClaim(claims, decoded, sourceName));\n      } catch (err) {\n        err.src = sourceName;\n        throw err;\n      }\n    }));\n    cleanUpClaims(claims);\n    return claims;\n  }\n  /**\n   * @name register\n   * @api public\n   */\n\n\n  static async register(properties, {\n    initialAccessToken,\n    jwks\n  } = {}) {\n    assertIssuerConfiguration(this.issuer, 'registration_endpoint');\n\n    if (jwks !== undefined && !(properties.jwks || properties.jwks_uri)) {\n      const keystore = getKeystore.call(this, jwks);\n      properties.jwks = keystore.toJWKS(false);\n    }\n\n    const response = await request.call(this, {\n      headers: initialAccessToken ? {\n        Authorization: authorizationHeaderValue(initialAccessToken)\n      } : undefined,\n      json: true,\n      body: properties,\n      url: this.issuer.registration_endpoint,\n      method: 'POST'\n    });\n    const responseBody = processResponse(response, {\n      statusCode: 201,\n      bearer: true\n    });\n    return new this(responseBody, jwks);\n  }\n  /**\n   * @name metadata\n   * @api public\n   */\n\n\n  get metadata() {\n    const copy = {};\n    instance(this).get('metadata').forEach((value, key) => {\n      copy[key] = value;\n    });\n    return copy;\n  }\n  /**\n   * @name fromUri\n   * @api public\n   */\n\n\n  static async fromUri(registrationClientUri, registrationAccessToken, jwks) {\n    const response = await request.call(this, {\n      method: 'GET',\n      url: registrationClientUri,\n      json: true,\n      headers: {\n        Authorization: authorizationHeaderValue(registrationAccessToken)\n      }\n    });\n    const responseBody = processResponse(response, {\n      bearer: true\n    });\n    return new this(responseBody, jwks);\n  }\n  /**\n   * @name requestObject\n   * @api public\n   */\n\n\n  async requestObject(requestObject = {}, algorithms = {}) {\n    if (!isPlainObject(requestObject)) {\n      throw new TypeError('requestObject must be a plain object');\n    }\n\n    defaults(algorithms, {\n      sign: this.request_object_signing_alg,\n      encrypt: {\n        alg: this.request_object_encryption_alg,\n        enc: this.request_object_encryption_enc\n      }\n    }, {\n      sign: 'none'\n    });\n    let signed;\n    let key;\n    const alg = algorithms.sign;\n    const header = {\n      alg,\n      typ: 'JWT'\n    };\n    const payload = JSON.stringify(defaults({}, requestObject, {\n      iss: this.client_id,\n      aud: this.issuer.issuer,\n      client_id: this.client_id,\n      jti: random(),\n      iat: now(),\n      exp: now() + 300\n    }));\n\n    if (alg === 'none') {\n      signed = [base64url.encode(JSON.stringify(header)), base64url.encode(payload), ''].join('.');\n    } else {\n      const symmetric = alg.startsWith('HS');\n\n      if (symmetric) {\n        key = await this.joseSecret();\n      } else {\n        const keystore = instance(this).get('keystore');\n\n        if (!keystore) {\n          throw new TypeError(\"no keystore present for client, cannot sign using alg \".concat(alg));\n        }\n\n        key = keystore.get({\n          alg,\n          use: 'sig'\n        });\n\n        if (!key) {\n          throw new TypeError(\"no key to sign with found for alg \".concat(alg));\n        }\n      }\n\n      signed = jose.JWS.sign(payload, key, { ...header,\n        kid: symmetric ? undefined : key.kid\n      });\n    }\n\n    if (!algorithms.encrypt.alg) {\n      return signed;\n    }\n\n    const fields = {\n      alg: algorithms.encrypt.alg,\n      enc: algorithms.encrypt.enc,\n      cty: 'JWT'\n    };\n\n    if (fields.alg.match(/^(RSA|ECDH)/)) {\n      key = await this.issuer.key({\n        alg: fields.alg,\n        enc: fields.enc,\n        use: 'enc'\n      }, true);\n    } else {\n      key = await this.joseSecret(fields.alg === 'dir' ? fields.enc : fields.alg);\n    }\n\n    return jose.JWE.encrypt(signed, key, { ...fields,\n      kid: key.kty === 'oct' ? undefined : key.kid\n    });\n  }\n  /**\n   * @name issuer\n   * @api public\n   */\n\n\n  static get issuer() {\n    return issuer;\n  }\n  /**\n   * @name issuer\n   * @api public\n   */\n\n\n  get issuer() {\n    // eslint-disable-line class-methods-use-this\n    return issuer;\n  }\n  /* istanbul ignore next */\n\n\n  [inspect.custom]() {\n    return \"\".concat(this.constructor.name, \" \").concat(inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true\n    }));\n  }\n\n};\n\nmodule.exports.BaseClient = BaseClient;","map":null,"metadata":{},"sourceType":"script"}