{"ast":null,"code":"const _require = require('util'),\n      deprecate = _require.deprecate;\n\nconst _require2 = require('../help/key_object'),\n      createPublicKey = _require2.createPublicKey,\n      createPrivateKey = _require2.createPrivateKey,\n      createSecretKey = _require2.createSecretKey,\n      KeyObject = _require2.KeyObject;\n\nconst base64url = require('../help/base64url');\n\nconst isObject = require('../help/is_object');\n\nconst _require3 = require('../help/key_utils'),\n      jwkToPem = _require3.jwkToPem;\n\nconst errors = require('../errors');\n\nconst RSAKey = require('./key/rsa');\n\nconst ECKey = require('./key/ec');\n\nconst OKPKey = require('./key/okp');\n\nconst OctKey = require('./key/oct');\n\nconst importable = new Set(['string', 'buffer', 'object']);\n\nconst mergedParameters = (target = {}, source = {}) => {\n  return {\n    alg: source.alg,\n    key_ops: source.key_ops,\n    kid: source.kid,\n    use: source.use,\n    x5c: source.x5c,\n    x5t: source.x5t,\n    'x5t#S256': source['x5t#S256'],\n    ...target\n  };\n};\n\nconst asKey = (key, parameters, {\n  calculateMissingRSAPrimes = false\n} = {}) => {\n  let privateKey, publicKey, secret;\n\n  if (!importable.has(typeof key)) {\n    throw new TypeError('key argument must be a string, buffer or an object');\n  }\n\n  if (parameters !== undefined && !isObject(parameters)) {\n    throw new TypeError('parameters argument must be a plain object when provided');\n  }\n\n  if (key instanceof KeyObject) {\n    switch (key.type) {\n      case 'private':\n        privateKey = key;\n        break;\n\n      case 'public':\n        publicKey = key;\n        break;\n\n      case 'secret':\n        secret = key;\n        break;\n    }\n  } else if (typeof key === 'object' && key && 'kty' in key && key.kty === 'oct') {\n    // symmetric key <Object>\n    try {\n      secret = createSecretKey(base64url.decodeToBuffer(key.k));\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err;\n      }\n\n      if (!('k' in key)) {\n        secret = {\n          type: 'secret'\n        };\n      }\n    }\n\n    parameters = mergedParameters(parameters, key);\n  } else if (typeof key === 'object' && key && 'kty' in key) {\n    // assume JWK formatted asymmetric key <Object>\n    var _ref = parameters || {\n      calculateMissingRSAPrimes\n    };\n\n    var _ref$calculateMissing = _ref.calculateMissingRSAPrimes;\n    calculateMissingRSAPrimes = _ref$calculateMissing === void 0 ? false : _ref$calculateMissing;\n    let pem;\n\n    try {\n      pem = jwkToPem(key, {\n        calculateMissingRSAPrimes\n      });\n    } catch (err) {\n      if (err instanceof errors.JOSEError) {\n        throw err;\n      }\n    }\n\n    if (pem && key.d) {\n      privateKey = createPrivateKey(pem);\n    } else if (pem) {\n      publicKey = createPublicKey(pem);\n    }\n\n    parameters = mergedParameters({}, key);\n  } else if (key && (typeof key === 'object' || typeof key === 'string')) {\n    // <Object> | <string> | <Buffer> passed to crypto.createPrivateKey or crypto.createPublicKey or <Buffer> passed to crypto.createSecretKey\n    try {\n      privateKey = createPrivateKey(key);\n    } catch (err) {}\n\n    try {\n      publicKey = createPublicKey(key);\n    } catch (err) {}\n\n    try {\n      // this is to filter out invalid PEM keys and certs, i'll rather have them fail import then\n      // have them imported as symmetric \"oct\" keys\n      if (!key.includes('-----BEGIN')) {\n        secret = createSecretKey(Buffer.isBuffer(key) ? key : Buffer.from(key));\n      }\n    } catch (err) {}\n  }\n\n  const keyObject = privateKey || publicKey || secret;\n\n  if (privateKey || publicKey) {\n    switch (keyObject.asymmetricKeyType) {\n      case 'rsa':\n        return new RSAKey(keyObject, parameters);\n\n      case 'ec':\n        return new ECKey(keyObject, parameters);\n\n      case 'ed25519':\n      case 'ed448':\n      case 'x25519':\n      case 'x448':\n        return new OKPKey(keyObject, parameters);\n\n      default:\n        throw new errors.JOSENotSupported('only RSA, EC and OKP asymmetric keys are supported');\n    }\n  } else if (secret) {\n    return new OctKey(keyObject, parameters);\n  }\n\n  throw new errors.JWKImportFailed('key import failed');\n};\n\nmodule.exports = asKey;\nObject.defineProperty(asKey, 'deprecated', {\n  value: deprecate((key, parameters) => {\n    return asKey(key, parameters, {\n      calculateMissingRSAPrimes: true\n    });\n  }, 'JWK.importKey() is deprecated, use JWK.asKey() instead'),\n  enumerable: false\n});","map":null,"metadata":{},"sourceType":"script"}