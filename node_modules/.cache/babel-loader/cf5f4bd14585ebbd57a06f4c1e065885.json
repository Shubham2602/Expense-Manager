{"ast":null,"code":"const merge = require('lodash/merge');\n\nconst omitBy = require('lodash/omitBy');\n\nconst jose = require('jose');\n\nconst _require = require('./assert'),\n      assertIssuerConfiguration = _require.assertIssuerConfiguration;\n\nconst _require2 = require('./generators'),\n      random = _require2.random;\n\nconst now = require('./unix_timestamp');\n\nconst request = require('./request');\n\nconst instance = require('./weak_cache');\n\nconst formUrlEncode = value => encodeURIComponent(value).replace(/%20/g, '+');\n\nasync function clientAssertion(endpoint, payload) {\n  let alg = this[\"\".concat(endpoint, \"_endpoint_auth_signing_alg\")];\n\n  if (!alg) {\n    assertIssuerConfiguration(this.issuer, \"\".concat(endpoint, \"_endpoint_auth_signing_alg_values_supported\"));\n  }\n\n  if (this[\"\".concat(endpoint, \"_endpoint_auth_method\")] === 'client_secret_jwt') {\n    const key = await this.joseSecret();\n\n    if (!alg) {\n      const supported = this.issuer[\"\".concat(endpoint, \"_endpoint_auth_signing_alg_values_supported\")];\n      alg = Array.isArray(supported) && supported.find(signAlg => key.algorithms('sign').has(signAlg));\n    }\n\n    return jose.JWS.sign(payload, key, {\n      alg,\n      typ: 'JWT'\n    });\n  }\n\n  const keystore = instance(this).get('keystore');\n\n  if (!keystore) {\n    throw new TypeError('no client jwks provided for signing a client assertion with');\n  }\n\n  if (!alg) {\n    const algs = new Set();\n    keystore.all().forEach(key => {\n      key.algorithms('sign').forEach(Set.prototype.add.bind(algs));\n    });\n    const supported = this.issuer[\"\".concat(endpoint, \"_endpoint_auth_signing_alg_values_supported\")];\n    alg = Array.isArray(supported) && supported.find(signAlg => algs.has(signAlg));\n  }\n\n  const key = keystore.get({\n    alg,\n    use: 'sig'\n  });\n\n  if (!key) {\n    throw new TypeError(\"no key found in client jwks to sign a client assertion with using alg \".concat(alg));\n  }\n\n  return jose.JWS.sign(payload, key, {\n    alg,\n    typ: 'JWT',\n    kid: key.kid\n  });\n}\n\nasync function authFor(endpoint, {\n  clientAssertionPayload\n} = {}) {\n  const authMethod = this[\"\".concat(endpoint, \"_endpoint_auth_method\")];\n\n  switch (authMethod) {\n    case 'self_signed_tls_client_auth':\n    case 'tls_client_auth':\n    case 'none':\n      return {\n        body: {\n          client_id: this.client_id\n        }\n      };\n\n    case 'client_secret_post':\n      if (!this.client_secret) {\n        throw new TypeError('client_secret_post client authentication method requires a client_secret');\n      }\n\n      return {\n        body: {\n          client_id: this.client_id,\n          client_secret: this.client_secret\n        }\n      };\n\n    case 'private_key_jwt':\n    case 'client_secret_jwt':\n      {\n        const timestamp = now();\n        const assertion = await clientAssertion.call(this, endpoint, {\n          iat: timestamp,\n          exp: timestamp + 60,\n          jti: random(),\n          iss: this.client_id,\n          sub: this.client_id,\n          aud: this.issuer[\"\".concat(endpoint, \"_endpoint\")],\n          // TODO: in v4.x pass the issuer instead (for now clientAssertionPayload can be used for that)\n          ...clientAssertionPayload\n        });\n        return {\n          body: {\n            client_id: this.client_id,\n            client_assertion: assertion,\n            client_assertion_type: 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer'\n          }\n        };\n      }\n\n    default:\n      {\n        // client_secret_basic\n        // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the\n        // related appendix. (also https://github.com/panva/node-openid-client/pull/91)\n        // > The client identifier is encoded using the\n        // > \"application/x-www-form-urlencoded\" encoding algorithm per\n        // > Appendix B, and the encoded value is used as the username; the client\n        // > password is encoded using the same algorithm and used as the\n        // > password.\n        if (!this.client_secret) {\n          throw new TypeError('client_secret_basic client authentication method requires a client_secret');\n        }\n\n        const encoded = \"\".concat(formUrlEncode(this.client_id), \":\").concat(formUrlEncode(this.client_secret));\n        const value = Buffer.from(encoded).toString('base64');\n        return {\n          headers: {\n            Authorization: \"Basic \".concat(value)\n          }\n        };\n      }\n  }\n}\n\nfunction resolveResponseType() {\n  const _this$response_types = this.response_types,\n        length = _this$response_types.length,\n        value = _this$response_types[0];\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nfunction resolveRedirectUri() {\n  const _ref = this.redirect_uris || [],\n        length = _ref.length,\n        value = _ref[0];\n\n  if (length === 1) {\n    return value;\n  }\n\n  return undefined;\n}\n\nasync function authenticatedPost(endpoint, opts, {\n  clientAssertionPayload,\n  endpointAuthMethod = endpoint\n} = {}) {\n  const auth = await authFor.call(this, endpointAuthMethod, {\n    clientAssertionPayload\n  });\n  const requestOpts = merge(opts, auth, {\n    form: true\n  });\n  const mTLS = this[\"\".concat(endpointAuthMethod, \"_endpoint_auth_method\")].includes('tls_client_auth');\n  let targetUrl;\n\n  if (mTLS) {\n    try {\n      targetUrl = this.issuer.mtls_endpoint_aliases[\"\".concat(endpoint, \"_endpoint\")];\n    } catch (err) {}\n  }\n\n  targetUrl = targetUrl || this.issuer[\"\".concat(endpoint, \"_endpoint\")];\n\n  if ('body' in requestOpts) {\n    requestOpts.body = omitBy(requestOpts.body, arg => arg === undefined);\n  }\n\n  return request.call(this, { ...requestOpts,\n    method: 'POST',\n    url: targetUrl\n  }, {\n    mTLS\n  });\n}\n\nmodule.exports = {\n  resolveResponseType,\n  resolveRedirectUri,\n  authFor,\n  authenticatedPost\n};","map":null,"metadata":{},"sourceType":"script"}