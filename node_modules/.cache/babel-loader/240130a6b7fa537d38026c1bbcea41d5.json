{"ast":null,"code":"const _require = require('crypto'),\n      generateKeyPairSync = _require.generateKeyPairSync,\n      async = _require.generateKeyPair;\n\nconst _require2 = require('util'),\n      promisify = _require2.promisify;\n\nconst _require3 = require('../../help/consts'),\n      THUMBPRINT_MATERIAL = _require3.THUMBPRINT_MATERIAL,\n      JWK_MEMBERS = _require3.JWK_MEMBERS,\n      PUBLIC_MEMBERS = _require3.PUBLIC_MEMBERS,\n      PRIVATE_MEMBERS = _require3.PRIVATE_MEMBERS,\n      KEY_MANAGEMENT_DECRYPT = _require3.KEY_MANAGEMENT_DECRYPT,\n      KEY_MANAGEMENT_ENCRYPT = _require3.KEY_MANAGEMENT_ENCRYPT;\n\nconst _require4 = require('../../help/runtime_support'),\n      oaepHashSupported = _require4.oaepHashSupported,\n      keyObjectSupported = _require4.keyObjectSupported;\n\nconst _require5 = require('../../help/key_object'),\n      createPublicKey = _require5.createPublicKey,\n      createPrivateKey = _require5.createPrivateKey;\n\nconst Key = require('./base');\n\nconst generateKeyPair = promisify(async);\nconst SIG_ALGS = ['PS256', 'RS256', 'PS384', 'RS384', 'PS512', 'RS512'];\nconst WRAP_ALGS = ['RSA-OAEP', 'RSA1_5'];\n\nif (oaepHashSupported) {\n  WRAP_ALGS.splice(1, 0, 'RSA-OAEP-256');\n}\n\nconst RSA_PUBLIC = new Set(['e', 'n']);\nObject.freeze(RSA_PUBLIC);\nconst RSA_PRIVATE = new Set([...RSA_PUBLIC, 'd', 'p', 'q', 'dp', 'dq', 'qi']);\nObject.freeze(RSA_PRIVATE);\n\nconst sigAlgsAvailableFor = length => {\n  switch (true) {\n    case length >= 1040:\n      return new Set(SIG_ALGS);\n\n    case length >= 784:\n      return new Set(['PS256', 'RS256', 'PS384', 'RS384', 'RS512']);\n\n    case length >= 752:\n      return new Set(['PS256', 'RS256', 'RS384', 'RS512']);\n\n    case length >= 624:\n      return new Set(['PS256', 'RS256', 'RS384']);\n\n    case length >= 528:\n      return new Set(['PS256', 'RS256']);\n\n    default:\n      return new Set(['RS256']);\n  }\n};\n\nconst wrapAlgsAvailableFor = length => {\n  switch (true) {\n    case length >= 784:\n      return new Set(WRAP_ALGS);\n\n    case length >= 592:\n      return new Set(['RSA-OAEP', 'RSA1_5']);\n\n    default:\n      return new Set(['RSA1_5']);\n  }\n};\n\nconst privateApi = Symbol('privateApi'); // RSA Key Type\n\nclass RSAKey extends Key {\n  constructor(...args) {\n    super(...args);\n    this[JWK_MEMBERS]();\n    Object.defineProperties(this, {\n      kty: {\n        value: 'RSA',\n        enumerable: true\n      },\n      length: {\n        get() {\n          Object.defineProperty(this, 'length', {\n            value: Buffer.byteLength(this.n, 'base64') * 8,\n            configurable: false\n          });\n          return this.length;\n        },\n\n        configurable: true\n      }\n    });\n  }\n\n  static get [PUBLIC_MEMBERS]() {\n    return RSA_PUBLIC;\n  }\n\n  static get [PRIVATE_MEMBERS]() {\n    return RSA_PRIVATE;\n  } // https://tc39.github.io/ecma262/#sec-ordinaryownpropertykeys no need for any special\n  // JSON.stringify handling in V8\n\n\n  [THUMBPRINT_MATERIAL]() {\n    return {\n      e: this.e,\n      kty: 'RSA',\n      n: this.n\n    };\n  }\n\n  algorithms(operation,\n  /* the rest is private API */\n  int, opts) {\n    const _ref = int === privateApi ? opts : {},\n          _ref$use = _ref.use,\n          use = _ref$use === void 0 ? this.use : _ref$use,\n          _ref$alg = _ref.alg,\n          alg = _ref$alg === void 0 ? this.alg : _ref$alg,\n          _ref$key_ops = _ref.key_ops,\n          ops = _ref$key_ops === void 0 ? this.key_ops : _ref$key_ops;\n\n    if (alg) {\n      return new Set(this.algorithms(operation, privateApi, {\n        alg: null,\n        use,\n        key_ops: ops\n      }).has(alg) ? [alg] : undefined);\n    }\n\n    if (operation === KEY_MANAGEMENT_ENCRYPT) {\n      operation = 'wrapKey';\n    } else if (operation === KEY_MANAGEMENT_DECRYPT) {\n      operation = 'unwrapKey';\n    }\n\n    if (operation && ops && !ops.includes(operation)) {\n      return new Set();\n    }\n\n    switch (operation) {\n      case 'deriveKey':\n      case 'encrypt':\n      case 'decrypt':\n        return new Set();\n\n      case 'sign':\n        if (this.public || use === 'enc') {\n          return new Set();\n        }\n\n        return sigAlgsAvailableFor(this.length);\n\n      case 'verify':\n        if (use === 'enc') {\n          return new Set();\n        }\n\n        return sigAlgsAvailableFor(this.length);\n\n      case 'wrapKey':\n        if (use === 'sig') {\n          return new Set();\n        }\n\n        return wrapAlgsAvailableFor(this.length);\n\n      case 'unwrapKey':\n        if (this.public || use === 'sig') {\n          return new Set();\n        }\n\n        return wrapAlgsAvailableFor(this.length);\n\n      case undefined:\n        // just the ops needed to return all algs regardless of its use\n        return new Set([...this.algorithms('sign'), ...this.algorithms('verify'), ...this.algorithms('wrapKey'), ...this.algorithms('unwrapKey')]);\n\n      default:\n        throw new TypeError('invalid key operation');\n    }\n  }\n\n  static async generate(len = 2048, privat = true) {\n    if (!Number.isSafeInteger(len) || len < 512 || len % 8 !== 0 || 'electron' in process.versions && len % 128 !== 0) {\n      throw new TypeError('invalid bit length');\n    }\n\n    let privateKey, publicKey;\n\n    if (keyObjectSupported) {\n      var _ref2 = await generateKeyPair('rsa', {\n        modulusLength: len\n      });\n\n      privateKey = _ref2.privateKey;\n      publicKey = _ref2.publicKey;\n      return privat ? privateKey : publicKey;\n    }\n\n    var _ref3 = await generateKeyPair('rsa', {\n      modulusLength: len,\n      publicKeyEncoding: {\n        type: 'spki',\n        format: 'pem'\n      },\n      privateKeyEncoding: {\n        type: 'pkcs8',\n        format: 'pem'\n      }\n    });\n\n    privateKey = _ref3.privateKey;\n    publicKey = _ref3.publicKey;\n\n    if (privat) {\n      return createPrivateKey(privateKey);\n    } else {\n      return createPublicKey(publicKey);\n    }\n  }\n\n  static generateSync(len = 2048, privat = true) {\n    if (!Number.isSafeInteger(len) || len < 512 || len % 8 !== 0 || 'electron' in process.versions && len % 128 !== 0) {\n      throw new TypeError('invalid bit length');\n    }\n\n    let privateKey, publicKey;\n\n    if (keyObjectSupported) {\n      var _generateKeyPairSync = generateKeyPairSync('rsa', {\n        modulusLength: len\n      });\n\n      privateKey = _generateKeyPairSync.privateKey;\n      publicKey = _generateKeyPairSync.publicKey;\n      return privat ? privateKey : publicKey;\n    }\n\n    var _generateKeyPairSync2 = generateKeyPairSync('rsa', {\n      modulusLength: len,\n      publicKeyEncoding: {\n        type: 'spki',\n        format: 'pem'\n      },\n      privateKeyEncoding: {\n        type: 'pkcs8',\n        format: 'pem'\n      }\n    });\n\n    privateKey = _generateKeyPairSync2.privateKey;\n    publicKey = _generateKeyPairSync2.publicKey;\n\n    if (privat) {\n      return createPrivateKey(privateKey);\n    } else {\n      return createPublicKey(publicKey);\n    }\n  }\n\n}\n\nmodule.exports = RSAKey;","map":null,"metadata":{},"sourceType":"script"}