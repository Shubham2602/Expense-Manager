{"ast":null,"code":"const _require = require('../errors'),\n      JOSECritNotUnderstood = _require.JOSECritNotUnderstood,\n      JWSInvalid = _require.JWSInvalid;\n\nconst DEFINED = new Set(['alg', 'jku', 'jwk', 'kid', 'x5u', 'x5c', 'x5t', 'x5t#S256', 'typ', 'cty', 'crit', 'enc', 'zip', 'epk', 'apu', 'apv', 'iv', 'tag', 'p2s', 'p2c']);\n\nmodule.exports = function validateCrit(Err, protectedHeader, unprotectedHeader, understood) {\n  if (protectedHeader && 'crit' in protectedHeader) {\n    if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some(s => typeof s !== 'string' || !s)) {\n      throw new Err('\"crit\" Header Parameter MUST be an array of non-empty strings when present');\n    }\n\n    const whitelisted = new Set(understood);\n    const combined = { ...protectedHeader,\n      ...unprotectedHeader\n    };\n    protectedHeader.crit.forEach(parameter => {\n      if (DEFINED.has(parameter)) {\n        throw new Err(\"The critical list contains a non-extension Header Parameter \".concat(parameter));\n      }\n\n      if (!whitelisted.has(parameter)) {\n        throw new JOSECritNotUnderstood(\"critical \\\"\".concat(parameter, \"\\\" is not understood\"));\n      }\n\n      if (parameter === 'b64') {\n        if (!('b64' in protectedHeader)) {\n          throw new JWSInvalid('\"b64\" critical parameter must be integrity protected');\n        }\n\n        if (typeof protectedHeader.b64 !== 'boolean') {\n          throw new JWSInvalid('\"b64\" critical parameter must be a boolean');\n        }\n      } else if (!(parameter in combined)) {\n        throw new Err(\"critical parameter \\\"\".concat(parameter, \"\\\" is missing\"));\n      }\n    });\n  }\n\n  if (unprotectedHeader && 'crit' in unprotectedHeader) {\n    throw new Err('\"crit\" Header Parameter MUST be integrity protected when present');\n  }\n};","map":null,"metadata":{},"sourceType":"script"}