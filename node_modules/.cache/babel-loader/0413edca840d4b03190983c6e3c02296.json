{"ast":null,"code":"const _require = require('util'),\n      inspect = _require.inspect;\n\nconst url = require('url');\n\nconst jose = require('jose');\n\nconst pAny = require('p-any');\n\nconst LRU = require('lru-cache');\n\nconst objectHash = require('object-hash');\n\nconst _require2 = require('./errors'),\n      RPError = _require2.RPError;\n\nconst getClient = require('./client');\n\nconst registry = require('./issuer_registry');\n\nconst processResponse = require('./helpers/process_response');\n\nconst webfingerNormalize = require('./helpers/webfinger_normalize');\n\nconst instance = require('./helpers/weak_cache');\n\nconst request = require('./helpers/request');\n\nconst _require3 = require('./helpers/assert'),\n      assertIssuerConfiguration = _require3.assertIssuerConfiguration;\n\nconst _require4 = require('./helpers/consts'),\n      ISSUER_DEFAULTS = _require4.ISSUER_DEFAULTS,\n      OIDC_DISCOVERY = _require4.OIDC_DISCOVERY,\n      OAUTH2_DISCOVERY = _require4.OAUTH2_DISCOVERY,\n      WEBFINGER = _require4.WEBFINGER,\n      REL = _require4.REL,\n      AAD_MULTITENANT_DISCOVERY = _require4.AAD_MULTITENANT_DISCOVERY;\n\nconst AAD_MULTITENANT = Symbol('AAD_MULTITENANT');\n\nclass Issuer {\n  /**\n   * @name constructor\n   * @api public\n   */\n  constructor(meta = {}) {\n    const aadIssValidation = meta[AAD_MULTITENANT];\n    delete meta[AAD_MULTITENANT];\n    ['introspection', 'revocation'].forEach(endpoint => {\n      // if intro/revocation endpoint auth specific meta is missing use the token ones if they\n      // are defined\n      if (meta[\"\".concat(endpoint, \"_endpoint\")] && meta[\"\".concat(endpoint, \"_endpoint_auth_methods_supported\")] === undefined && meta[\"\".concat(endpoint, \"_endpoint_auth_signing_alg_values_supported\")] === undefined) {\n        if (meta.token_endpoint_auth_methods_supported) {\n          meta[\"\".concat(endpoint, \"_endpoint_auth_methods_supported\")] = meta.token_endpoint_auth_methods_supported;\n        }\n\n        if (meta.token_endpoint_auth_signing_alg_values_supported) {\n          meta[\"\".concat(endpoint, \"_endpoint_auth_signing_alg_values_supported\")] = meta.token_endpoint_auth_signing_alg_values_supported;\n        }\n      }\n    });\n    Object.entries(meta).forEach(([key, value]) => {\n      instance(this).get('metadata').set(key, value);\n\n      if (!this[key]) {\n        Object.defineProperty(this, key, {\n          get() {\n            return instance(this).get('metadata').get(key);\n          },\n\n          enumerable: true\n        });\n      }\n    });\n    instance(this).set('cache', new LRU({\n      max: 100\n    }));\n    registry.set(this.issuer, this);\n    Object.defineProperty(this, 'Client', {\n      value: getClient(this, aadIssValidation)\n    });\n  }\n  /**\n   * @name keystore\n   * @api public\n   */\n\n\n  async keystore(reload = false) {\n    assertIssuerConfiguration(this, 'jwks_uri');\n    const keystore = instance(this).get('keystore');\n    const cache = instance(this).get('cache');\n\n    if (reload || !keystore) {\n      cache.reset();\n      const response = await request.call(this, {\n        method: 'GET',\n        json: true,\n        url: this.jwks_uri\n      });\n      const jwks = processResponse(response);\n      const joseKeyStore = jose.JWKS.asKeyStore(jwks, {\n        ignoreErrors: true\n      });\n      cache.set('throttle', true, 60 * 1000);\n      instance(this).set('keystore', joseKeyStore);\n      return joseKeyStore;\n    }\n\n    return keystore;\n  }\n  /**\n   * @name key\n   * @api private\n   */\n\n\n  async key({\n    kid,\n    kty,\n    alg,\n    use,\n    key_ops: ops\n  }, allowMulti = false) {\n    const cache = instance(this).get('cache');\n    const def = {\n      kid,\n      kty,\n      alg,\n      use,\n      key_ops: ops\n    };\n    const defHash = objectHash(def, {\n      algorithm: 'sha256',\n      ignoreUnknown: true,\n      unorderedArrays: true,\n      unorderedSets: true\n    }); // refresh keystore on every unknown key but also only upto once every minute\n\n    const freshJwksUri = cache.get(defHash) || cache.get('throttle');\n    const keystore = await this.keystore(!freshJwksUri);\n    const keys = keystore.all(def);\n\n    if (keys.length === 0) {\n      throw new RPError({\n        printf: [\"no valid key found in issuer's jwks_uri for key parameters %j\", def],\n        jwks: keystore\n      });\n    }\n\n    if (!allowMulti) {\n      if (keys.length !== 1) {\n        throw new RPError({\n          printf: [\"multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case\", def],\n          jwks: keystore\n        });\n      }\n\n      cache.set(defHash, true);\n    }\n\n    return keys[0];\n  }\n  /**\n   * @name metadata\n   * @api public\n   */\n\n\n  get metadata() {\n    const copy = {};\n    instance(this).get('metadata').forEach((value, key) => {\n      copy[key] = value;\n    });\n    return copy;\n  }\n  /**\n   * @name webfinger\n   * @api public\n   */\n\n\n  static async webfinger(input) {\n    const resource = webfingerNormalize(input);\n\n    const _url$parse = url.parse(resource),\n          host = _url$parse.host;\n\n    const webfingerUrl = \"https://\".concat(host).concat(WEBFINGER);\n    const response = await request.call(this, {\n      method: 'GET',\n      url: webfingerUrl,\n      json: true,\n      query: {\n        resource,\n        rel: REL\n      },\n      followRedirect: true\n    });\n    const body = processResponse(response);\n    const location = Array.isArray(body.links) && body.links.find(link => typeof link === 'object' && link.rel === REL && link.href);\n\n    if (!location) {\n      throw new RPError({\n        message: 'no issuer found in webfinger response',\n        body\n      });\n    }\n\n    if (typeof location.href !== 'string' || !location.href.startsWith('https://')) {\n      throw new RPError({\n        printf: ['invalid issuer location %s', location.href],\n        body\n      });\n    }\n\n    const expectedIssuer = location.href;\n\n    if (registry.has(expectedIssuer)) {\n      return registry.get(expectedIssuer);\n    }\n\n    const issuer = await this.discover(expectedIssuer);\n\n    if (issuer.issuer !== expectedIssuer) {\n      registry.delete(issuer.issuer);\n      throw new RPError('discovered issuer mismatch, expected %s, got: %s', expectedIssuer, issuer.issuer);\n    }\n\n    return issuer;\n  }\n  /**\n   * @name discover\n   * @api public\n   */\n\n\n  static async discover(uri) {\n    const parsed = url.parse(uri);\n\n    if (parsed.pathname.includes('/.well-known/')) {\n      const response = await request.call(this, {\n        method: 'GET',\n        json: true,\n        url: uri\n      });\n      const body = processResponse(response);\n      return new Issuer({ ...ISSUER_DEFAULTS,\n        ...body,\n        [AAD_MULTITENANT]: AAD_MULTITENANT_DISCOVERY.has(uri)\n      });\n    }\n\n    const uris = [];\n\n    if (parsed.pathname === '/') {\n      uris.push(\"\".concat(OAUTH2_DISCOVERY));\n    } else {\n      uris.push(\"\".concat(OAUTH2_DISCOVERY).concat(parsed.pathname));\n    }\n\n    if (parsed.pathname.endsWith('/')) {\n      uris.push(\"\".concat(parsed.pathname).concat(OIDC_DISCOVERY.substring(1)));\n    } else {\n      uris.push(\"\".concat(parsed.pathname).concat(OIDC_DISCOVERY));\n    }\n\n    return pAny(uris.map(async pathname => {\n      const wellKnownUri = url.format({ ...parsed,\n        pathname\n      });\n      const response = await request.call(this, {\n        method: 'GET',\n        json: true,\n        url: wellKnownUri\n      });\n      const body = processResponse(response);\n      return new Issuer({ ...ISSUER_DEFAULTS,\n        ...body,\n        [AAD_MULTITENANT]: AAD_MULTITENANT_DISCOVERY.has(wellKnownUri)\n      });\n    }));\n  }\n  /* istanbul ignore next */\n\n\n  [inspect.custom]() {\n    return \"\".concat(this.constructor.name, \" \").concat(inspect(this.metadata, {\n      depth: Infinity,\n      colors: process.stdout.isTTY,\n      compact: false,\n      sorted: true\n    }));\n  }\n\n}\n\nmodule.exports = Issuer;","map":null,"metadata":{},"sourceType":"script"}